<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Realm of Shinobi: Tournament of Legends - PvP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Server config: change to wss/ngrok later -->
  <script>window.PVP_WS_URL = "wss://https://ros-relay.onrender.com/ws";</script>

  <style>
    :root{
      --topbar-h: 60px;
      --actionbar-h: 216px;
      --safe-bottom: 50px;
      --gap: 10px;

      --bg: #0f0f13; --ink: #e8e8f0; --border: #3a4257;
      --panel: #161a24; --battle-bg: #14141b;

      --act-row-h: 76px;
      --act-gap: 8px;
      --act-pad-x: 12px;
      --act-pad-y: 8px;

      --btn-frame-url: none;
      --btn-slice: 12;
      --btn-bg: rgba(18,24,36,.9);
    }

    html,body{
      margin:0; padding:0; height:100%;
      background:var(--bg); color:var(--ink); font-family:monospace;
    }

    /* App grid */
    #app{
      height: calc(100vh - var(--safe-bottom));
      display: grid;
      grid-template-rows: var(--topbar-h) minmax(0, 1fr) var(--actionbar-h);
      grid-template-columns: minmax(640px, 2fr) minmax(360px, 1fr);
      gap: var(--gap);
      padding: var(--gap);
      box-sizing: border-box;
      overflow: hidden;
    }

    #battlefield, #log-wrap, #action-bar-left, #action-bar-right, #top-left, #top-right {
      min-width: 0; min-height: 0;
    }

    /* Top row */
    #top-left, #top-right{
      height: 100%;
      min-height: 0;
      display:flex; align-items:center; justify-content:center;
      background:#1b2231;
      border:2px solid var(--border);
      box-sizing: border-box;
    }
    #top-left { grid-column: 1; grid-row: 1; font-weight:700; font-size:24px; }
    #top-right{ grid-column: 2; grid-row: 1; }

    /* Battlefield (left middle) */
    #battlefield{
      grid-column:1; grid-row:2;
      min-width: 640px;
      min-height: 480px;
      width: 100%;
      height: 100%;
      border:2px solid var(--border);
      background:var(--battle-bg);
      box-sizing:border-box;
      overflow:hidden;
    }
    #battlefield canvas { display:block; max-width:none; max-height:none; image-rendering:pixelated; }

    /* Combat Log (right middle) */
    #log-wrap{
      grid-column: 2; grid-row: 2;
      border:2px solid var(--border);
      background:var(--panel);
      display:flex; flex-direction:column;
      min-width: 360px;
      height: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }
    #combat-log{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      padding:10px 12px;
    }
    #combat-log h3{ margin:6px 0 10px 0; font-size:16px; color:#a7c4ff; }
    #combat-log .line{ font-size:15px; margin:2px 0; white-space:pre-wrap; }

    /* Bottom row */
    #action-bar-left, #action-bar-right{
      grid-row: 3;
      height: 100%;
      min-height: 0;
      overflow: hidden;
      border:2px solid var(--border);
      background:#1b2130;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: var(--act-pad-y) var(--act-pad-x) calc(var(--act-pad-y) + 4px);
      box-sizing: border-box;
    }
    #action-bar-left { grid-column: 1; }
    #action-bar-right{ grid-column: 2; }

    /* Action bar inner shell */
    #action-bar-inner{
      width: 100%;
      display:flex; flex-direction:column; gap:8px;
      align-items:center;
      min-width: 0;
    }
    #action-prompt{
      font-weight: 800;
      font-size: 24px;
      text-align: center;
      line-height: 1.2;
      margin: 0;
    }

    /* Fixed 3√ó2 grid */
    #action-buttons{
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      grid-template-rows: repeat(2, var(--act-row-h));
      gap: var(--act-gap);
      width: 100%;
      min-width: 0;
      align-items: stretch;
      justify-items: stretch;
      overflow: hidden;
      max-width: 96%;
      margin-inline: auto;
    }
    #action-buttons .action-btn{ width:100%; min-width:0; height:100%; box-sizing:border-box; padding:8px 10px; }
    #action-buttons .action-btn img{ width:24px; height:24px; image-rendering: pixelated; flex:0 0 auto; }

    /* Button look */
    .action-btn{
      background:#22314b; color:#fff; border:1px solid #4a5a7a; border-radius:4px;
      display:flex; flex-direction:column; align-items:flex-start; white-space:normal; line-height:1.2; cursor:pointer;
      transition: transform .08s ease-out;
    }
    .action-btn:hover{ background:#2a3b5b; transform: translateY(-1px); }
    .action-btn:active{ transform: translateY(0); box-shadow: 0 1px 0 rgba(0,0,0,.35); }
    .action-btn .label{ font-weight:800; font-size:24px; }
    .action-btn .desc{
      font-size:14px; opacity:.9; margin-top:4px;
      display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden;
    }
    .action-btn.placeholder{ opacity: .35; border-style:dashed; cursor:default; }
    .action-btn.placeholder:hover{ transform:none; background:#22314b; }
    .action-btn.placeholder .label{ opacity:.8; }
    .action-btn.placeholder .desc{ display:none; }

    /* Nine-slice (optional) */
    .has-frame #action-buttons .action-btn{
      border: var(--btn-slice) solid transparent;
      border-image-source: var(--btn-frame-url);
      border-image-slice: var(--btn-slice) fill;
      border-image-width: var(--btn-slice);
      border-image-repeat: stretch;
      background: var(--btn-bg);
      border-radius:0;
    }

/* Speed dots on action buttons */
.action-btn .speed {
  position: absolute;
  top: 6px;
  right: 6px;
  display: flex;
  gap: 4px;
  pointer-events: none;
  opacity: .95;
}
.action-btn .speed .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  opacity: .75;
}
.action-btn .speed .off { opacity: .25; filter: grayscale(100%); }

/* colors for speed */
.action-btn .speed.fast  .dot      { background:#7cfc7c; }  /* green */
.action-btn .speed.normal .dot     { background:#ffd37a; }  /* yellow */
.action-btn .speed.slow  .dot      { background:#ff6b6b; }  /* red */
/* Put dots on the far right in normal flow (not absolute) */
.action-btn .btn-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  width:100%;
}
.action-btn .speed.right{
  position: static;  /* override the absolute rule */
  top:auto; right:auto;
  margin-left:8px;
}

/* === Right-aligned speed dots (override any earlier rules) === */
.action-btn .btn-inner{
  display:flex;
  align-items:center;
  justify-content:space-between;
  width:100%;
  gap:8px;
}
.action-btn .btn-inner .text{
  display:flex;
  flex-direction:column;
  align-items:flex-start;
  min-width:0;
  flex:1; /* <-- this pushes the dots all the way to the right */
}
/* FORCE the dots to live on the right, not absolute */
.action-btn .speed{
  position:static !important;
  top:auto !important;
  right:auto !important;
  margin-left:8px;
  flex:0 0 auto;
}
.action-btn .speed .dot{
  display:inline-block;
  width:8px; height:8px; border-radius:50%;
  margin-left:3px;
  opacity:.9;
}
.action-btn .speed .dot.off{ opacity:.35; filter:grayscale(1); }


    /* Error overlay */
    #error-overlay{position:fixed;inset:0;display:none;z-index:99999;overflow:auto;background:rgba(20,20,26,.92);color:#ffcccc;padding:16px;border:2px solid #663333}
    #error-overlay h1{margin-top:0;color:#ffd4d4}
    #error-overlay pre{white-space:pre-wrap}
  </style>

  <!-- Phaser -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
  <div id="error-overlay"><h1>‚ö†Ô∏è Prototype Error</h1><div id="err-msg"></div></div>

  <div id="app">
    <!-- top row -->
    <div id="top-left">Initializing‚Ä¶</div>
    <div id="top-right"></div>

    <!-- middle row -->
    <div id="battlefield"></div>
    <div id="log-wrap">
      <div id="combat-log"><h3>üìú Combat Log</h3></div>
    </div>

    <!-- bottom row -->
    <div id="action-bar-left"></div>
    <div id="action-bar-right"></div>
  </div>

  <!-- ===== BIG SCRIPT (open across all parts) ===== -->
  <script>
/* ---------- tiny DOM helper ---------- */
window.el = window.el || function el(tag, attrs = {}, ...kids){
  const n = document.createElement(tag);
  for (const [k, v] of Object.entries(attrs || {})) {
    if (k === 'class') n.className = v;
    else if (k === 'style' && v && typeof v === 'object') Object.assign(n.style, v);
    else n.setAttribute(k, v);
  }
  for (const kid of kids) {
    if (kid == null) continue;
    if (typeof kid === 'string') n.appendChild(document.createTextNode(kid));
    else n.appendChild(kid);
  }
  return n;
};

/* ---------- error overlay ---------- */
(function(){
  function showErrorOverlay(m){
    var o=document.getElementById('error-overlay'), b=o.querySelector('#err-msg');
    b.innerHTML='<p><strong>Message:</strong></p><pre>'+ (m||'Unknown') +'</pre>'; o.style.display='block';
  }
  window.addEventListener('error',e=>{
    try{showErrorOverlay((e.message||'Error')+'\n'+(e.error&&e.error.stack?e.error.stack:''));}
    catch(_){showErrorOverlay(e.message||String(e));}
  });
})();

/* ---------- common DOM refs ---------- */
const topLeftEl     = document.getElementById('top-left');
const bfEl          = document.getElementById('battlefield');
const actionLeftEl  = document.getElementById('action-bar-left');

/* ---------- log helpers ---------- */
function appendLog(line){
  const logEl = document.getElementById('combat-log'); if (!logEl) return;
  const div=document.createElement('div'); div.className='line'; div.textContent=line;
  logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
}
function appendLogHTML(html){
  const logEl = document.getElementById('combat-log'); if (!logEl) return;
  const div=document.createElement('div'); div.className='line'; div.innerHTML=html;
  logEl.appendChild(div); logEl.scrollTop=logEl.scrollHeight;
}
function logGreen(txt){ appendLogHTML(`<span style="color:#9be29b">${txt}</span>`); }
function logRed(txt){ appendLogHTML(`<span style="color:#ff6b6b">${txt}</span>`); }
function checkHPWarnings(u){
  if (!u) return;
  const p = u.hp / u.maxHP;
  u._hpWarn70 ||= false; u._hpWarn35 ||= false; u._hpWarn15 ||= false;
  if (!u._hpWarn70 && p > 0 && p <= 0.70){ logRed(`${u.name} is hurt!`); u._hpWarn70 = true; }
  if (!u._hpWarn35 && p > 0 && p <= 0.35){ logRed(`${u.name} is hurt badly!`); u._hpWarn35 = true; }
  if (!u._hpWarn15 && p > 0 && p <= 0.15){ logRed(`${u.name} is about to die!`); u._hpWarn15 = true; }
  if (p > 0.70){ u._hpWarn70 = u._hpWarn35 = u._hpWarn15 = false; }
  else if (p > 0.35){ u._hpWarn35 = u._hpWarn15 = false; }
  else if (p > 0.15){ u._hpWarn15 = false; }
}

/* ---------- action bar shell ---------- */
let actionInnerEl, actionPromptEl, actionButtonsEl;
function initActionBarShell(){
  if (!actionLeftEl) return;
  actionLeftEl.innerHTML = '';
  actionInnerEl     = document.createElement('div'); actionInnerEl.id  = 'action-bar-inner';
  actionPromptEl    = document.createElement('div'); actionPromptEl.id = 'action-prompt';
  actionButtonsEl   = document.createElement('div'); actionButtonsEl.id= 'action-buttons';
  actionInnerEl.appendChild(actionPromptEl); actionInnerEl.appendChild(actionButtonsEl);
  actionLeftEl.appendChild(actionInnerEl);
}
function clearActionBar(){ if (actionButtonsEl) actionButtonsEl.innerHTML = ''; if (actionPromptEl) actionPromptEl.textContent = ''; }

/* ---------- tiny async helpers ---------- */
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const SLEEP_TINY_MS=1000, ACTION_DELAY_MS=1000, ACTION_STEP_DELAY_MS=1000, ROUND_END_DELAY_MS=1000;

/* ---------- RNG (unified, deterministic) ---------- */
(function(){
  let _s = 1 >>> 0; // non-zero
  function _xr(){ _s^=(_s<<13)>>>0; _s^=_s>>>17; _s^=(_s<<5)>>>0; _s>>>=0; return (_s>>>0)/0x100000000; }
  window.__seedRNG = function(seed){ _s = (seed>>>0) || 1; };
  window.rand = function(){ return _xr(); };
  window.randInt = function(min,max){ return Math.floor(rand()*(max-min+1))+min; };
  window.chance = function(p){ return rand() < p; };
  window.seedRNG = window.__seedRNG; // friendly alias
})();

/* ---------- utils ---------- */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const choice=(arr)=> arr[(rand()*arr.length)|0];

/* ---------- config ---------- */
const CONFIG = {
  BASE_HP: 50, HP_PER_TGH: 25,
  ATK_PER_STR: 1.5, SDM_PER_INT: 1.5,
  DEF_FROM_TGH: 0.75, DEF_FROM_QKN: 0.75,

  CC_BASE_MIN: 2, CC_BASE_MAX: 5, CC_SDM_PER_BONUS: 15, CC_MAX_CAP: 8,
  CRIT_BASE: 0.10, CRIT_CAP: 0.40, CRIT_QKN_FACTOR: 0.005, CRIT_INT_FACTOR: 0.005,
  DODGE_BASE: 0.025, DODGE_QKN_FACTOR: 0.0025, DODGE_CAP: 0.20,

  ARMOR_K: 0.025, DAMAGE_GLOBAL: 1.15,

  SHRUG_BASE: 0.025, SHRUG_TGH_FACTOR: 0.0025,

  BUFF_BASE_MIN: 2, BUFF_BASE_MAX: 7, BUFF_SDM_PER_BONUS: 15, BUFF_MAX_CAP: 9,

  PROC: {
    Cleric: { chance: 0.5 }, Mage: { chance: 0.5 }, Monk: { chance: 0.6 },
    Mystic: { chance: 0.5 }, Necromancer: { chance: 0.5 }, Paladin: { chance: 0.5 },
  },

  STACKS: { atk_up:{per:0.5,max:4}, sdm_up:{per:0.5,max:4}, def_up:{per:0.33,max:4}, def_down:{per:0.25,max:4} },

  MARKED_MULT: 2.0,
  ECHO_MULT: 1.20,
  SHIELDWALL_GUARD: 0.35,
  COUNTER_COEF: 0.30,
  STATCOEF_OVERRIDE: 1.0, // keep 1.0 to simplify tuning
  NO_GLOBAL_MULT: true,
  IGNORE_DEFPEN: false
};

/* ---------- ability type overrides ---------- */
window.ABILITY_TYPE_OVERRIDES = window.ABILITY_TYPE_OVERRIDES || {};
window.ABILITY_TYPE_OVERRIDES['Fireball'] = 'mag';
window.ABILITY_TYPE_OVERRIDES['Shield Bash'] = 'phys';
window.ABILITY_TYPE_OVERRIDES['Lightning Bolt (proc)'] = 'mag';
window.ABILITY_TYPE_OVERRIDES['Life Drip (proc)']     = 'mag';

// ---------- Ability damage-type overrides (mag vs phys) ----------
// Safe init
window.ABILITY_TYPE_OVERRIDES = window.ABILITY_TYPE_OVERRIDES || Object.create(null);

// Helper: set many labels to a type at once
function __setType(type, labels){
  const O = window.ABILITY_TYPE_OVERRIDES;
  for (const name of labels) { if (name) O[name] = type; }
}
// Helper: set a label and its common variants (proc / dot / tick)
function __setWithVariants(type, label, {proc=true, dot=false, tick=false} = {}){
  const names = [label];
  if (proc) names.push(`${label} (proc)`);
  if (dot)  names.push(`${label} (dot)`);
  if (tick) names.push(`${label} (tick)`);
  __setType(type, names);
}

// ---- MAGIC damage sources (resist via SDM) ----
__setType('mag', [
  // Mage / Mystic / Cleric / Paladin holy/arcane/shadow/poison/elemental
  'Fireball', 'Ice Lance', 'Frost Nova', 'Lightning Bolt', 'Arcane Surge',
  'Arcane Blast', 'Meteor', 'Magic Missile', 'Smite', 'Piercing Light',
  'Holy Nova', 'Radiant Spear', 'Judgement', 'Thunderstrike',
  'Life Drain', 'Shadow Bolt', 'Bone Spear', 'Mind Spike', 'Psionic Lash',
  'Chi Burst', 'Warding Flare'
]);

// Explicit procs/ticks that are magical
__setType('mag', [
  'Lightning Bolt (proc)', 'Life Drip (proc)', 'Arcane Echo (proc)',
  'Burn (dot)', 'Burn (tick)', 'Poison (dot)', 'Rot (dot)', 'Curse (proc)'
]);

// Abilities that apply magical DoTs or repeat magic
__setWithVariants('mag', 'Arcane Echo', {proc:true});
__setWithVariants('mag', 'Poison',     {proc:true, dot:true, tick:true}); // DoT ticks count as mag in this model
__setWithVariants('mag', 'Burn',       {proc:false, dot:true, tick:true});
__setWithVariants('mag', 'Rot',        {proc:false, dot:true, tick:true});
__setWithVariants('mag', 'Life Drip',  {proc:true}); // necro lifesteal proc
__setWithVariants('mag', 'Lightning Bolt', {proc:true});

// Paladin holy splash in your logs (treated as magic)
__setWithVariants('mag', 'Sanctify', {proc:false});

// Cleric beam in your logs (treated as magic)
__setWithVariants('mag', 'Piercing Light', {proc:false});

// Mage surge in your logs (treated as magic)
__setWithVariants('mag', 'Arcane Surge', {proc:true});

// ---- PHYSICAL damage sources (resist via DEF) ----
__setType('phys', [
  // Weapon / martial / arrows / bashes
  'Shield Bash', 'Shield Slam', 'Slash', 'Cleave', 'Whirlwind', 'Charge',
  'Crushing Blow', 'Uppercut', 'Palm Hit', 'Stun Kick', 'Flurry',
  'Snipe', 'Multi Shot', 'Volley', 'Piercing Arrow', 'Trap',
  'Backstab', 'Eviscerate', 'Poison Dagger', 'Execute', 'Frenzy', 'Smash', 'Leap'
]);

// Physical DoTs/Procs
__setType('phys', [
  'Bleed (dot)', 'Bleed (tick)', 'Counter (proc)'
]);

// Make sure these key labels from your logs are covered explicitly:
__setWithVariants('phys', 'Palm Hit');
__setWithVariants('phys', 'Snipe');
__setWithVariants('mag',  'Piercing Light');       // (already set above, but safe)
__setWithVariants('mag',  'Sanctify');             // (already set above, but safe)
__setWithVariants('phys', 'Poison Dagger');        // base hit is phys; its poison DoT is mag (set separately above)
__setWithVariants('mag',  'Hunter\'s Mark', {proc:false}); // mark is non-damage but leave as mag if any proc reads it
__setWithVariants('mag',  'Premonition',   {proc:false});  // status only; type won‚Äôt be used

// If you have unique names not in this list, add them here:
// window.ABILITY_TYPE_OVERRIDES['Your Ability'] = 'mag'; // or 'phys'

// ---------- END overrides ----------

/* ---------- jobs & stats ---------- */
const ALL_CLASSES = ['Warrior','Barbarian','Rogue','Cleric','Mage','Paladin','Archer','Monk','Necromancer','Mystic'];
const JOBS = {
  Warrior:  { STR:26,QKN:16,INT:8, TGH:30, kind:'phys', name:'Warrior' },
  Rogue:    { STR:22,QKN:30,INT:8,TGH:20,  kind:'phys', name:'Rogue' },
  Cleric:   { STR:7, QKN:18,INT:28,TGH:27, kind:'mag',  name:'Cleric' },
  Barbarian:{ STR:33,QKN:12, INT:7,TGH:28, kind:'phys', name:'Barbarian' },
  Mage:     { STR:8, QKN:14,INT:35,TGH:23, kind:'mag',  name:'Mage' },
  Paladin:  { STR:24,QKN:12,INT:16,TGH:28, kind:'phys', name:'Paladin' },
  Archer:   { STR:22,QKN:27,INT:8, TGH:23, kind:'phys', name:'Archer' },
  Monk:     { STR:24,QKN:28,INT:8, TGH:20, kind:'phys', name:'Monk' },
  Necromancer:{STR:7,QKN:14, INT:34,TGH:25, kind:'mag',  name:'Necromancer' },
  Mystic:   { STR:8, QKN:19,INT:31,TGH:22, kind:'mag',  name:'Mystic' }
};
function deriveStats(job){
  const HP  = CONFIG.BASE_HP + job.TGH*CONFIG.HP_PER_TGH;
  const ATK = job.STR*CONFIG.ATK_PER_STR;
  const SDM = job.INT*CONFIG.SDM_PER_INT;
  const DEF = job.TGH*CONFIG.DEF_FROM_TGH + job.QKN*CONFIG.DEF_FROM_QKN;
  const CRIT = CONFIG.CRIT_BASE + (CONFIG.CRIT_BONUS?.[job.name]||0);
  return { HP:Math.round(HP), ATK, SDM, DEF, CRIT };
}
function makeUnit(jobName, team){
  const job = JOBS[jobName], d = deriveStats(job);
  const u = new Unit(jobName, team, jobName);
  u.maxHP = d.HP; u.hp = d.HP;
  u.ATK = d.ATK; u.SDM = d.SDM; u.DEF = d.DEF; u.CRIT = d.CRIT;
  return u;
}
class Unit{
  constructor(name, team, jobName){
    const job = JOBS[jobName], d = deriveStats(job);
    this.name = name || jobName;
    this.team = team;
    this.job  = jobName;
    this.kind = job.kind;
    this.maxHP = d.HP; this.hp = d.HP;
    this.ATK = d.ATK; this.SDM = d.SDM; this.DEF = d.DEF;
    this.CRIT = d.CRIT;
    this.status = [];
    this._ui = null;
  }
  alive(){ return this.hp>0; }
}

/* ---------- abilities (now with min/max healing where relevant) ---------- */
function abilitiesFor(u){
  switch(u.job){

    /* ===== Warrior ===== */
case 'Warrior': return [
  {label:'Attack', desc:'Regular old melee strike.', speed:'normal', type:'phys', target:'enemy',
   base:{min:35,max:45}, statCoef:0.35, isBasic:true,
   use:function(a,t){ return hit(a,t,{ability:this}); } },

  {label:'Warhorn', desc:'Heal and briefly bolster yourself with strength and quickness.',
   speed:'slow', type:'phys', target:'self',
   use:(a)=>{
     // ATK‚Üë ‚Äî 1 stack for 3 rounds
     const atkDur = 3;
     pushStatus(a, { key:'atk_up', dur: atkDur });

     // Premonition ‚Äî acts at fast speed next round
     // Use dur:2 so it survives the current end-of-round tick.
     const preDur = 2;
     pushStatus(a, { key:'premonition', dur: preDur });

     // Small personal heal that scales a bit with ATK
     const healSpec = { heal:{ min:10, max:18 }, healCoef:0.18, scalesWith:'ATK', type:'mag' };
     const H = computeAbilityHeal(a, a, healSpec);
     const before = a.hp;
     a.hp = clamp(a.hp + H, 0, a.maxHP);
     a._refresh && a._refresh(); checkHPWarnings(a);

     appendLog(`${a.name} sounds the Warhorn and surges with a burst of strength and quickness. ${a.name} is healed for ${a.hp - before}.`);
   }}, // <-- important comma here

  {label:'Power Strike', desc:'Slow, heavy blow.', speed:'slow', type:'phys', target:'enemy',
   base:{min:40,max:80}, statCoef:0.60,
   use:function(a,t){ return hit(a,t,{ability:this}); } },

  {label:'Taunt', desc:'Taunt an enemy into attacking you.', speed:'normal', type:'phys', target:'enemy',
   use:(a,t)=>{
     if(!t.alive()) return appendLog(`${a.name}'s Taunt has no effect on the dead.`);
     if(rand()<0.75){
       const dur=ccDurBySDM(a);
       pushStatus(t,{ key:'taunt', dur, data:{ taunter:a }});
       appendLogHTML(`<span style="color:#b084ff">${a.name} taunts ${t.name}! ${t.name} must attack ${a.name} for ${dur} round(s).</span>`);
     } else {
       appendLog(`${a.name}'s Taunt fails.`);
     }
   }},

  {label:'Shieldwall', desc:'Allies gain mitigation; intercept first hit.', speed:'fast', type:'phys', target:'all-allies',
   use:(a,arr)=>{
     for (const ally of arr){
       pushStatus(ally, { key:'guard', dur:1, data:{ pct:(CONFIG.SHIELDWALL_GUARD||0.35) }});
     }
     pushStatus(a, { key:'shield_redirect', dur:1, data:{ remaining:1 }});
     appendLogHTML(`${a.name} raises <b>Shieldwall</b> to protect the team!`);
   }}
];


    /* ===== Barbarian ===== */
    case 'Barbarian': return [
      {label:'Attack', desc:'A basic attack.', speed:'normal', type:'phys', target:'enemy',
       base:{min:30,max:55}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Rend', desc:'Expose your target‚Äôs weakness.', speed:'slow', type:'phys', target:'enemy',
       base:{min:20,max:80}, statCoef:0.35,
       use:function(a,t){ const r=hit(a,t,{ability:this});
         if(t.alive()){ const dur=buffDurBySDM(a); pushStatus(t,{key:'def_down', dur}); appendLog(`${t.name}‚Äôs defense is lowered (${dur}).`);} return r; } },

      {label:'War Cry', desc:'Damage all enemies and lower their defense.', speed:'normal', type:'mag', target:'all-enemies',
       base:{min:10,max:20}, statCoef:0.25,
       use:function(a,arr){ for(const t of arr){ if(!t.alive()) continue; hit(a,t,{ability:this}); }
         const dur=buffDurBySDM(a); for(const t of arr){ if(!t.alive()) continue; pushStatus(t,{key:'def_down', dur}); }
         appendLog(`All enemies‚Äô defense is reduced (${dur}).`); } },

      {label:'Smash', desc:'Crushing blow with chance to stun.', speed:'slow', type:'phys', target:'enemy',
       base:{min:30,max:70}, statCoef:0.55,
       use:function(a,t){ const r=hit(a,t,{ability:this}); if(t.alive() && rand()<0.25){ const dur=ccDurBySDM(a);
         applyStatusWithLog(t,'stun',dur,'#b084ff',`${t.name} is stunned for {dur} rounds!`);} return r; } },

      {label:'Rampage', desc:'Swing that grants rampage on killshot.', speed:'normal', type:'phys', target:'enemy',
       base:{min:25,max:60}, statCoef:0.45,
       use:function(a,t){
         const hpBefore = t.hp;
         const r = hit(a,t,{ability:this});
         if (hpBefore>0 && t.hp<=0){
           const dur = (buffDurBySDM(a)+1);
           pushStatus(a,{key:'atk_up', dur});
           appendLogHTML(`<span style="color:#ff927a">${a.name} goes on a Rampage! ATK‚Üë (${dur}).</span>`);
         }
         return r;
       }}
    ];

    /* ===== Rogue ===== */
    case 'Rogue': return [
      {label:'Quick Slash', desc:'Quickly strike a vital area.', speed:'fast', type:'phys', target:'enemy',
       base:{min:30,max:40}, statCoef:0.40, critBonus:0.50,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Attack', desc:'Stab your enemy in the leg.', speed:'normal', type:'phys', target:'enemy',
       base:{min:35,max:45}, statCoef:0.45, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Poison Dagger', desc:'Cover your blade with poison for this attack.', speed:'normal', type:'phys', target:'enemy',
       base:{min:20,max:25}, statCoef:0.30,
       use:function(a,t){
         const r = hit(a,t,{ability:this});
         if (t.alive() && r.dealt > 0){
           addPoison(t, r.dealt);
           logGreen(`${t.name} is poisoned (+${r.dealt}).`);
         }
         return r;
       }},

      {label:'Shadowstep', desc:'Strike quickly and defend.', speed:'fast', type:'phys', target:'enemy',
       base:{min:25,max:30}, statCoef:0.30,
       use:function(a,t){
         const r = hit(a,t,{ability:this});
         const dur = buffDurBySDM(a);
         pushStatus(a,{key:'def_up', dur});
         appendLog(`${a.name} slips back and guards (${dur}).`);
         return r;
       }},

      {label:'Smoke Bomb', desc:'Blind all enemies this round.', speed:'fast', type:'phys', target:'all-enemies',
       use:(a,arr)=>{
         let n = 0;
         for (const t of arr){ if (!t.alive()) continue; pushStatus(t,{key:'blind', dur:1}); n++; }
         appendLogHTML(`${a.name} throws <b>Smoke Bomb</b>! ${n} enemies are blinded this round.`);
       }}
    ];

    /* ===== Cleric ===== */
case 'Cleric': return [
  {
    label: 'Defensive Aura',
    desc: 'Heal an ally and bolster their defense.',
    speed: 'fast', type: 'mag', target: 'ally',
    heal: { min: 15, max: 30 }, healCoef: 0.25, scalesWith: 'SDM',
    use: (a, t) => {
      const dur = buffDurBySDM(a);
      pushStatus(t, { key: 'def_up', dur });
      const H = computeAbilityHeal(a, t, { heal: { min: 15, max: 30 }, healCoef: 0.25, scalesWith: 'SDM', type: 'mag' });
      const before = t.hp;
      t.hp = clamp(t.hp + H, 0, t.maxHP);
      const healed = t.hp - before;
      t._refresh && t._refresh(); checkHPWarnings(t);
      appendLog(`${a.name} blesses ${t.name} with a Defensive Aura: DEF‚Üë (${dur}), healed for ${healed}.`);
    }
  },

  {
    label: 'Attack',
    desc: 'Basic strike with a holy mace.',
    speed: 'normal', type: 'phys', target: 'enemy',
    base: { min: 8, max: 16 }, statCoef: 0.75, isBasic: true,
    use: function(a, t){ return hit(a, t, { ability: this }); }
  },

  {
    label: `Enid's Blessing`,
    desc: 'Heal all allies and cure poison.',
    speed: 'slow', type: 'mag', target: 'all-allies',
    heal: { min: 15, max: 45 }, healCoef: 0.40, scalesWith: 'SDM',
    use: (a, arr) => {
      for (const ally of arr){
        if (!ally.alive()) continue;
        const H = computeAbilityHeal(a, ally, { heal:{ min:10, max:30 }, healCoef:0.40, scalesWith:'SDM', type:'mag' });
        const before = ally.hp;
        ally.hp = clamp(ally.hp + H, 0, ally.maxHP);
        removeStatusKey(ally, 'poison');
        ally._refresh && ally._refresh(); checkHPWarnings(ally);
        appendLog(`${a.name} channels Enid‚Äôs Blessing: ${ally.name} healed for ${ally.hp - before} and cured of poison.`);
      }
    }
  },

  {
    label: 'Piercing Light',
    desc: 'Holy bolt that pierces defense.',
    speed: 'slow', type: 'mag', target: 'enemy',
    base: { min: 35, max: 50 }, statCoef: 0.55, defPen: 0.25,
    use: function(a, t){ return hit(a, t, { ability: this }); }
  },

  {
    label: 'Resurrection',
    desc: 'Revive a fallen ally (once) or heal if alive.',
    speed: 'slow', type: 'mag', target: 'ally', allowDeadTarget: true,
    use: (a, t) => {
      if (a._rezUsed){
        appendLog(`${a.name} has already used Resurrection.`);
        return;
      }
      if (t.alive()){
        const H = computeAbilityHeal(a, t, { heal:{ min:20, max:40 }, healCoef:0.30, scalesWith:'SDM', type:'mag' });
        const before = t.hp;
        t.hp = clamp(t.hp + H, 0, t.maxHP);
        t._refresh && t._refresh(); checkHPWarnings(t);
        appendLog(`${t.name} is already alive ‚Äî healed for ${t.hp - before}.`);
      } else {
        t.hp = Math.max(1, Math.floor(t.maxHP * 0.35));
        removeStatusKey(t, 'poison');
        t._refresh && t._refresh(); checkHPWarnings(t);
        appendLogHTML(`<span style="color:#a7c4ff">‚úù ${a.name} resurrects ${t.name} with ${t.hp} HP!</span>`);
        a._rezUsed = true;
      }
    }
  },
];


    /* ===== Mage ===== */
    case 'Mage': return [
      {label:'Arcane Surge', desc:'Increase your defense and casting power.', speed:'fast', type:'mag', target:'self',
       use:(a)=>{ const dur=buffDurBySDM(a); pushStatus(a,{key:'def_up', dur}); pushStatus(a,{key:'sdm_up', dur});
         appendLog(`${a.name} is warded and empowered (${dur}).`);} },

      {label:'Attack', desc:'Basic attack with lightning dagger.', speed:'normal', type:'phys', target:'enemy',
       base:{min:10,max:20}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Meteor', desc:'Fast meteor strike with chance to stun.', speed:'fast', type:'mag', target:'enemy',
       base:{min:15,max:45}, statCoef:0.45,
       use:function(a,t){ const r=hit(a,t,{ability:this}); if(t.alive() && rand()<0.25){ const dur=ccDurBySDM(a);
         applyStatusWithLog(t,'stun',dur,'#b084ff',`${t.name} is dazed for {dur} rounds!`);} return r; } },

      {label:'Fireball', desc:'Large fireball that scorches all foes.', speed:'slow', type:'mag', target:'all-enemies',
       base:{min:20,max:70}, statCoef:0.50, defPen:0.20,
       use:function(a,arr){ for(const t of arr){ if(!t.alive()) continue; hit(a,t,{ability:this}); } } },

      {label:'Arcane Echo', desc:'Your spells cast twice next turn.', speed:'fast', type:'mag', target:'self',
       use:(a)=>{ pushStatus(a,{key:'arcane_echo', dur:2}); appendLog(`${a.name} prepares an arcane echo.`); }}
    ];

    /* ===== Paladin ===== */
    case 'Paladin': return [
      {label:'Attack', desc:'Basic sword & board attack.', speed:'normal', type:'phys', target:'enemy',
       base:{min:35,max:50}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Shield Bash', desc:'Bash with chance to stun.', speed:'normal', type:'phys', target:'enemy',
       base:{min:20,max:30}, statCoef:0.35,
       use:function(a,t){ const r=hit(a,t,{ability:this}); if(t.alive() && rand()<0.30){ const dur=ccDurBySDM(a);
         applyStatusWithLog(t,'stun',dur,'#b084ff',`${t.name} is stunned for {dur} rounds!`);} return r; } },

      {label:'Cleanse', desc:'Remove ailments and heal.', speed:'slow', type:'mag', target:'ally',
 heal:{min:6,max:12}, healCoef:0.50, scalesWith:'SDM',
 use:function(a,t){
   const removed = cleanseCCAndDebuffs(t);
   const H = computeAbilityHeal(a,t,this);
   const before = t.hp;
   t.hp = clamp(t.hp + H, 0, t.maxHP);
   const healed = t.hp - before;
   t._refresh && t._refresh(); if (typeof checkHPWarnings==='function') checkHPWarnings(t);
   const removedText = removed ? ' ailments removed,' : '';
   appendLog(`${a.name} casts Cleanse on ${t.name}:${removedText} healed for ${healed}.`);
}},


      {label:'Sanctify', desc:'Smite all enemies.', speed:'slow', type:'mag', target:'all-enemies',
       base:{min:10,max:40}, statCoef:0.40,
       use:function(a,arr){ for(const t of arr){ if(!t.alive()) continue; hit(a,t,{ability:this}); } } },

      {label:'Divine Shield', desc:'One ally takes no damage this round.', speed:'fast', type:'mag', target:'ally',
       use:(a,t)=>{ pushStatus(t,{key:'divine_shield', dur:1}); appendLog(`${a.name} acts heroically, ${t.name} is protected by Divine Shield.`); }}
    ];

    /* ===== Archer ===== */
    case 'Archer': return [
      {label:`Ranger's Focus`, desc:'Heal an ally and boost their attack.', speed:'fast', type:'mag', target:'ally',
       heal:{min:20,max:30}, healCoef:0.25, scalesWith:'ATK',
       use:(a,t)=>{
  const dur = buffDurBySDM(a);
  pushStatus(t,{key:'atk_up', dur});
  const H = computeAbilityHeal(a,t,{ heal:{min:8,max:13}, healCoef:0.25, scalesWith:'ATK', type:'mag' });
  const before = t.hp;
  t.hp = clamp(t.hp + H, 0, t.maxHP);
  const healed = t.hp - before;
  t._refresh && t._refresh(); checkHPWarnings(t);
  appendLog(`${a.name} focuses ${t.name}: ATK‚Üë (${dur}), healed for ${healed}.`);
}},

      {label:'Attack', desc:'Loose a precise arrow.', speed:'normal', type:'phys', target:'enemy',
       base:{min:35,max:40}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Volley', desc:'Rain arrows on all enemies.', speed:'normal', type:'phys', target:'all-enemies',
       base:{min:5,max:45}, statCoef:0.30,
       use:function(a,arr){ for(const t of arr){ if(!t.alive()) continue; hit(a,t,{ability:this}); } } },

      {label:'Snipe', desc:'Take careful aim for the vitals.', speed:'slow', type:'phys', target:'enemy',
       base:{min:40,max:95}, statCoef:0.65, critBonus:0.30,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:`Hunter's Mark`, desc:'Target takes increased damage until end of next round.', speed:'fast', type:'phys', target:'enemy',
       use:(a,t)=>{ if(!t.alive()) return appendLog(`${t.name} is already down.`);
         pushStatus(t,{key:'marked', dur:2});
         appendLogHTML(`${a.name} targets ${t.name} with <b>Hunter's Mark</b>. <span style="color:#ffd37a">${t.name} is now more susceptible to damage!</span>`);
       }}
    ];

    /* ===== Monk ===== */
    case 'Monk': return [
      {label:'Flurry', desc:'Three rapid strikes.', speed:'fast', type:'phys', target:'enemy',
       base:{min:25,max:30}, statCoef:0.25,
       use:function(a,t){ for(let i=1;i<=3;i++){ if(!t.alive()) break;
         a._usingAbilityLabel = `Flurry (${i}/3)`; hit(a,t,{ability:this}); a._usingAbilityLabel = undefined; } } },

      {label:'Attack', desc:'Strike with confidence.', speed:'normal', type:'phys', target:'enemy',
       base:{min:40,max:50}, statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Chi Wave', desc:'Cleanse CC/debuffs from all allies.', speed:'normal', type:'mag', target:'all-allies',
       use:(a,arr)=>{ let count=0; for(const ally of arr){ if(!ally.alive()) continue;
         if(cleanseCCAndDebuffs(ally)) count++; updateStatusView(ally); }
         appendLog(count ? `A Chi Wave rips accross the battlefield. Negative effects washed away from ${count} allies.` : `No negative effects to cleanse.`); } },

      {label:'Palm Hit', desc:'Quick strike; may stagger.', speed:'fast', type:'phys', target:'enemy',
       base:{min:25,max:35}, statCoef:0.30,
       use:function(a,t){ const r=hit(a,t,{ability:this}); if(t.alive() && rand()<0.25){ const dur=ccDurBySDM(a);
         applyStatusWithLog(t,'stun',dur,'#b084ff',`${t.name} is staggered for {dur} rounds!`);} return r; } },

      {label:'Counterstance', desc:'Guard and counter basic attacks.', speed:'fast', type:'phys', target:'self',
       use:(a)=>{ pushStatus(a,{key:'guard', dur:1, data:{ pct:0.40 }}); pushStatus(a,{key:'counter', dur:1}); appendLog(`${a.name} adopts a counter stance.`); }}
    ];

    /* ===== Necromancer ===== */
    case 'Necromancer': return [
      {label:'Attack', desc:'Basic attack with chance to drain.', speed:'normal', type:'phys', target:'enemy',
       base:{min:10,max:20}, statCoef:0.40, isBasic:true,
       use:function(a,t){
         const r = hit(a,t,{ability:this});
         if (t.alive() && rand() < 0.35){
           const dur = buffDurBySDM(a);
           pushStatus(t,{key:'def_down', dur});
           appendLog(`${t.name} is sapped of vigor (${dur}).`);
         }
         return r;
       }},

      {label:'Life Drain', desc:'Steal life from a foe.', speed:'normal', type:'mag', target:'enemy',
       base:{min:25,max:50}, statCoef:0.35,
       use:function(a,t){
         const res = computeAbilityDamage(a,t,this);
         if (res.dodged || !res.hit){ appendLog(`${a.name}'s Life Drain fails to take hold.`); return; }
         const dealt = Math.max(1, res.dmg);
         t.hp = clamp(t.hp - dealt, 0, t.maxHP);
         a.hp = clamp(a.hp + dealt, 0, a.maxHP);
         t._refresh&&t._refresh(); a._refresh&&a._refresh(); checkHPWarnings(t); checkHPWarnings(a);
         if (res.crit){
           appendLogHTML(`${a.name}‚Äôs spell lands a <span style="color:gold">critical</span> drain! ${t.name} loses ${dealt}. ${a.name} is healed for ${dealt}.`);
         } else {
           appendLog(`Life Drain siphons ${dealt} from ${t.name}. ${a.name} is healed for ${dealt}.`);
         }
       }},

      {label:'Plague', desc:'Afflict all foes with massive poison.', speed:'slow', type:'mag', target:'all-enemies',
       base:{min:10,max:40}, statCoef:0.30,
       use:function(a,arr){
         for (const t of arr){
           if (!t.alive()) continue;
           const res = computeAbilityDamage(a, t, this);
           if (res.hit && !res.dodged && res.dmg > 0){
             addPoison(t, res.dmg);
             logGreen(`${t.name} is afflicted by plague (+${res.dmg}).`);
           } else {
             appendLog(`${a.name}'s Plague misses ${t.name}.`);
           }
         }
       }},

      {label:'Death Touch', desc:'Crush half the foe‚Äôs current life.', speed:'slow', type:'mag', target:'enemy',
       use:(a,t)=>{
         if (!t.alive()) return appendLog(`${t.name} is already down.`);
         const half = Math.floor(t.hp / 2);
         t.hp = clamp(t.hp - half, 0, t.maxHP);
         t._refresh && t._refresh(); checkHPWarnings(t);
         appendLogHTML(`<span style="color:#ff6b6b">${a.name} invokes Death Touch! ${t.name} loses ${half} HP.</span>`);
       }},

      {label:'Plague Detonation', desc:'Consume all poison for an instant burst.', speed:'normal', type:'mag', target:'all-enemies',
       use:(a,arr)=>{
         let hits = 0;
         for (const t of arr){
           if (!t.alive()) continue;
           const total = poisonTotal(t);
           if (total <= 0){ appendLog(`${t.name} has no poison to detonate.`); continue; }
           removeStatusKey(t,'poison');
           let dmg = Math.floor(total * (CONFIG.DAMAGE_GLOBAL||1));
           if (hasStatus(t,'marked')) dmg = Math.floor(dmg * (CONFIG.MARKED_MULT||1.25));
           t.hp = clamp(t.hp - dmg, 0, t.maxHP);
           t._refresh && t._refresh(); checkHPWarnings(t);
           appendLogHTML(`<span style="color:#9be29b">${t.name} suffers ${dmg} from exploding plague.</span>`);
           hits++;
         }
         if (!hits) appendLog(`No poisons to detonate.`);
       }}
    ];

    /* ===== Mystic ===== */
    case 'Mystic': return [
      {label:'Stun', desc:'Quickly stun your foe.', speed:'fast', type:'mag', target:'enemy',
       use:(a,t)=>{
         if(rand()<0.55){ const dur=ccDurBySDM(a);
           applyStatusWithLog(t,'stun',dur,'#b084ff',`${a.name} stuns ${t.name} for {dur} rounds!`);
         } else { appendLog(`${a.name}'s Stun fails.`); }
       } },

      {label:'Attack', desc:'A crack of mental force.', speed:'normal', type:'mag', target:'enemy',
       base:{min:20,max:25}, scalesWith:'SDM', statCoef:0.40, isBasic:true,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Berserk', desc:'Target loses control; may attack anyone.', speed:'normal', type:'mag', target:'enemy',
       use:(a,t)=>{
         if(rand()<0.55){ const dur=ccDurBySDM(a);
           applyStatusWithLog(t,'berserk',dur,'#b084ff',`${a.name} drives ${t.name} berserk for {dur} rounds!`);
         } else { appendLog(`${a.name}'s Berserk fails to take hold.`); }
       } },

      {label:'Mental Breakdown', desc:'Crushing psychic blow.', speed:'slow', type:'mag', target:'enemy',
       base:{min:30,max:70}, scalesWith:'SDM', statCoef:0.55,
       use:function(a,t){ return hit(a,t,{ability:this}); } },

      {label:'Premonition', desc:'All ally actions become fast next round.', speed:'fast', type:'mag', target:'all-allies',
       use:(a,arr)=>{ for (const ally of arr){ if(ally.alive()) pushStatus(ally,{key:'premonition', dur:2}); }
         appendLogHTML(`${a.name} invokes <b>Premonition</b> ‚Äî your party acts faster next round.`); } }
    ];

    default:
      return [
        {label:'Attack', desc:'A basic strike.', speed:'normal', type:u.kind==='mag'?'mag':'phys', target:'enemy',
         base:{min:20,max:25}, scalesWith:u.kind==='mag'?'SDM':'ATK', statCoef:0.35, isBasic:true,
         use:function(a,t){ return hit(a,t,{ability:this}); } }
      ];
  }
}

/* ===== PART 2/4 ‚Äî ENGINE HELPERS ===== */

/* ---------- Status & stacking ---------- */
const STACKABLE = new Set(['atk_up','sdm_up','def_up','def_down']);
function hasStatus(u,key){ return u.status && u.status.some(s=>s.key===key); }
function countStacks(u, key){ let n=0; for(const s of (u.status||[])) if (s.key===key) n++; return n; }
function pushStatus(u, st){
  if (!u || !st) return; if (!u.status) u.status=[];
  if (STACKABLE.has(st.key)){ const dur=Math.max(1, st.dur|0); u.status.push({ key:st.key, dur, data:{ stack:1 } }); }
  else if (st.key==='stun'||st.key==='blind'||st.key==='berserk'||st.key==='taunt'){
    const existing = u.status.find(s=>s.key===st.key);
    if (existing){ const cap=CONFIG.CC_MAX_CAP??8; existing.dur=Math.min(cap, existing.dur+Math.floor((st.dur|0)*0.5)); }
    else { u.status.push({ key:st.key, dur:st.dur|0, data:st.data }); }
  } else { u.status.push(st); }
  updateStatusView(u);
}
function removeStatusKey(u, key){
  if (!u || !u.status) return false;
  const before=u.status.length; u.status=u.status.filter(s=>s.key!==key);
  if (u._refresh) u._refresh(); return u.status.length!==before;
}
function cleanseCCAndDebuffs(u){
  const toStrip=new Set(['stun','taunt','blind','berserk','def_down','poison']);
  if (!u || !u.status) return false; const before=u.status.length;
  u.status=u.status.filter(s=>!toStrip.has(s.key)); if (u._refresh) u._refresh();
  return u.status.length!==before;
}

/* ---------- Poison engine ---------- */
function addPoison(target, amount){
  if (!target || amount<=0) return;
  let st = target.status.find(s=>s.key==='poison');
  if (!st){ st={ key:'poison', dur:9999, data:{ contributions:[] } }; target.status.push(st); }
  const list = st.data.contributions || (st.data.contributions=[]);
  list.push({ amt: Math.max(1, Math.floor(amount)) }); updateStatusView(target);
}
function poisonTotal(u){
  const st=u.status.find(s=>s.key==='poison'); const list=st?.data?.contributions;
  if (!Array.isArray(list)||!list.length) return 0;
  return list.reduce((s,c)=>s+(c.amt|0),0);
}

/* ---------- durations & log helpers ---------- */
function buffDurBySDM(caster){
  const min=CONFIG.BUFF_BASE_MIN??2, max=CONFIG.BUFF_BASE_MAX??7, step=CONFIG.BUFF_SDM_PER_BONUS??15, cap=CONFIG.BUFF_MAX_CAP??8;
  const roll=min+randInt(0,Math.max(0,max-min)); const bonus=Math.floor(Math.max(0,caster?.SDM||0)/step);
  return Math.min(cap, roll+bonus);
}
function ccDurBySDM(caster){
  const min=CONFIG.CC_BASE_MIN??2, max=CONFIG.CC_BASE_MAX??6, step=CONFIG.CC_SDM_PER_BONUS??15, cap=CONFIG.CC_MAX_CAP??8;
  const roll=min+randInt(0,Math.max(0,max-min)); const bonus=Math.floor(Math.max(0,caster?.SDM||0)/step);
  return Math.min(cap, roll+bonus);
}
function applyStatusWithLog(target, statusKey, dur, colorHex, text){
  pushStatus(target,{key:statusKey,dur});
  const msg = text && text.includes('{dur}') ? text.replace('{dur}', dur) : `${text || statusKey} (${dur} rounds).`;
  appendLogHTML(`<span style="color:${colorHex}">${msg}</span>`);
  return dur;
}

/* ---------- deterministic picks (no RNG before seeding) ---------- */
function pickCanonical(arr){
  if (!arr || !arr.length) return null;
  return [...arr].sort((a,b)=> (a.name||'').localeCompare(b.name||''))[0];
}
function pickDeterministic(arr){ // safe alias
  return pickCanonical(arr);
}

/* ---------- multipliers ---------- */
function atkMult(u){ const cfg=CONFIG.STACKS?.atk_up||{per:0.25,max:4}; const n=Math.min(countStacks(u,'atk_up'),cfg.max); return Math.pow(1+cfg.per, n); }
function sdmMult(u){ const cfg=CONFIG.STACKS?.sdm_up||{per:0.25,max:4}; const n=Math.min(countStacks(u,'sdm_up'),cfg.max); return Math.pow(1+cfg.per, n); }
function defMult(u){
  const upCfg=CONFIG.STACKS?.def_up||{per:0.25,max:4}, downCfg=CONFIG.STACKS?.def_down||{per:0.20,max:4};
  const upN=Math.min(countStacks(u,'def_up'),upCfg.max); const downN=Math.min(countStacks(u,'def_down'),downCfg.max);
  return Math.pow(1+upCfg.per, upN) * Math.pow(1-downCfg.per, downN);
}

/* ---------- combat math (damage) ---------- */
function critChance(attacker, type){
  const q=JOBS[attacker.job].QKN, it=JOBS[attacker.job].INT;
  const BASE=CONFIG.CRIT_BASE??0.10, CAP=CONFIG.CRIT_CAP??0.40;
  const PER_Q=CONFIG.CRIT_QKN_FACTOR??0.005, PER_I=CONFIG.CRIT_INT_FACTOR??0.005;
  let p = BASE + (type==='phys' ? q*PER_Q : it*PER_I);
  return Math.min(CAP, Math.max(0,p));
}
function tryDodge(attacker, defender, type){
  if(type!=='phys') return false;
  const q=JOBS[defender.job].QKN, base=CONFIG.DODGE_BASE??0.05, factor=CONFIG.DODGE_QKN_FACTOR??0.0025, cap=CONFIG.DODGE_CAP??0.25;
  const p = Math.min(cap, Math.max(0, base + q*factor));
  return defender.alive() && chance(p);
}
function applyDefense(raw, defender, defPen=0){
  const effDEF=Math.max(0, defender.DEF*defMult(defender)*(1-defPen));
  const K=CONFIG.ARMOR_K??0.025; const red = effDEF/(effDEF+1/K);
  return Math.max(1, Math.floor(raw * (1 - red)));
}
function getAbilityType(attacker, ability){
  const forced=(ability&&ability.label&&window.ABILITY_TYPE_OVERRIDES[ability.label]);
  return (forced || ability?.type || (attacker?.kind || 'phys'));
}
function getAbilityScalesWith(attacker, ability, type){
  if (ability?.scalesWith) return ability.scalesWith;
  return (type==='mag')?'SDM':'ATK';
}
function abilityBasePower(ability){
  if (!ability) return 0;
  if (Number.isFinite(ability.power)) return ability.power|0;
  const b=ability.base||{min:0,max:0}, min=b.min|0, max=b.max|0;
  return min + randInt(0, Math.max(0, max - min));
}
function computeAbilityDamage(attacker, defender, ability){
  const type=getAbilityType(attacker,ability);
  const scalesWith=getAbilityScalesWith(attacker,ability,type);
  const statValue=(scalesWith==='SDM')?attacker.SDM:attacker.ATK;
  const offMult=(scalesWith==='SDM')?sdmMult(attacker):atkMult(attacker);
  const coef=Number.isFinite(CONFIG.STATCOEF_OVERRIDE)?CONFIG.STATCOEF_OVERRIDE:(ability?.statCoef??0);
  let dmg = Math.max(0, abilityBasePower(ability) + Math.floor(statValue * coef * offMult));
  if (type==='phys' && tryDodge(attacker, defender,'phys')) return {hit:false,dmg:0,crit:false,dodged:true,_type:type};
  let isCrit=false; const pCrit=Math.min(1, Math.max(0, critChance(attacker,type)+(ability?.critBonus??0)));
  if (chance(pCrit)){ dmg=Math.floor(dmg*1.75); isCrit=true; }
  const defPen=CONFIG.IGNORE_DEFPEN?0:(ability?.defPen||0);
  dmg=applyDefense(dmg, defender, defPen);
  if (!CONFIG.NO_GLOBAL_MULT) dmg=Math.floor(dmg*(CONFIG.DAMAGE_GLOBAL||1));
  return {hit:true,dmg,crit:isCrit,dodged:false,_type:type};
}

// HEALING MATH //

function computeAbilityHeal(caster, target, ability){
  // shape mirrors computeAbilityDamage, but positive and without defense
  const base = ability?.heal || { min:0, max:0 };
  const min = base.min|0, max = base.max|0;
  const roll = min + randInt(0, Math.max(0, max - min));

  const scalesWith = ability?.scalesWith || 'SDM';
  const statValue  = (scalesWith === 'SDM') ? caster.SDM : caster.ATK;

  const coef = Number.isFinite(ability?.healCoef) ? ability.healCoef : 0.0;

  // buffed stats affect heals too (SDM‚Üë/ATK‚Üë)
  const offMult = (scalesWith === 'SDM') ? sdmMult(caster) : atkMult(caster);

  let H = Math.max(0, roll + Math.floor(statValue * coef * offMult));

  if (!CONFIG.NO_GLOBAL_MULT) H = Math.floor(H * (CONFIG.DAMAGE_GLOBAL || 1));
  return H|0;
}




/* lightweight raw calc */
function calcDamage(a,t,opt){
  const type=opt.type||(a.kind==='mag'?'mag':'phys');
  const fakeAbility={ label:opt.verb||'Attack', type, base:{min:opt.baseMin??0,max:opt.baseMax??0},
    scalesWith:(type==='mag')?'SDM':'ATK', statCoef:Number.isFinite(CONFIG.STATCOEF_OVERRIDE)?CONFIG.STATCOEF_OVERRIDE:1.0 };
  const r=computeAbilityDamage(a,t,fakeAbility);
  return {hit:r.hit,dmg:r.dmg,crit:r.crit,dodged:r.dodged};
}

/* ---------- procs on basic ---------- */
function maybeProcOnBasic(attacker, target){
  const cfg=CONFIG.PROC?.[attacker.job]; if(!cfg||rand()>=(cfg.chance??0)) return;
  switch(attacker.job){
    case 'Cleric':{
      const heal=Math.max(1, Math.floor((6+randInt(0,5)) + attacker.SDM*0.20));
      const total=Math.floor(heal*(CONFIG.DAMAGE_GLOBAL||1));
      attacker.hp=clamp(attacker.hp+total,0,attacker.maxHP); attacker._refresh&&attacker._refresh(); checkHPWarnings(attacker);
      appendLogHTML(`<span style="color:#a7c4ff">‚ú® A prayer mends ${attacker.name} for ${total}.</span>`); break;
    }
    case 'Mage':{
      const bolt={label:'Lightning Bolt (proc)', type:'mag', speed:'fast', base:{min:10,max:16}, scalesWith:'SDM', statCoef:0.35, defPen:0.10};
      const r=computeAbilityDamage(attacker,target,bolt); if(r.hit){ target.hp=clamp(target.hp-r.dmg,0,target.maxHP);
        target._refresh&&target._refresh(); checkHPWarnings(target);
        appendLogHTML(`<span style="color:#a7c4ff">‚ö° A lightning bolt zaps ${target.name} for ${r.dmg}!</span>`); }
      break;
    }
    case 'Monk':{ const dur=buffDurBySDM(attacker); pushStatus(attacker,{key:'atk_up',dur});
      appendLogHTML(`<span style="color:#a7c4ff">üåÄ ${attacker.name} finds an opening: ATK‚Üë (${dur}).</span>`); break; }
    case 'Mystic':{ if(!target||!target.alive()) return; const dur=buffDurBySDM(attacker);
      pushStatus(target,{key:'def_down',dur}); appendLogHTML(`<span style="color:#a7c4ff">ü™Ñ ${target.name}'s guard falters: DEF‚Üì (${dur}).</span>`); break; }
    case 'Necromancer':{
      const drip={label:'Life Drip (proc)', type:'mag', speed:'fast', base:{min:6,max:10}, scalesWith:'SDM', statCoef:0.30};
      const r=computeAbilityDamage(attacker,target,drip);
      if(r.hit){ target.hp=clamp(target.hp-r.dmg,0,target.maxHP); attacker.hp=clamp(attacker.hp+r.dmg,0,attacker.maxHP);
        target._refresh&&target._refresh(); attacker._refresh&&attacker._refresh(); checkHPWarnings(target); checkHPWarnings(attacker);
        appendLogHTML(`<span style="color:#a7c4ff">ü©∏ A dark sip steals ${r.dmg} from ${target.name}.</span>`); }
      break;
    }
    case 'Paladin':{ const dur=buffDurBySDM(attacker); pushStatus(attacker,{key:'def_up',dur});
      appendLogHTML(`<span style="color:#a7c4ff">üõ°Ô∏è ${attacker.name}'s resolve hardens: DEF‚Üë (${dur}).</span>`); break; }
  }
}

/* ---------- status UI badges ---------- */
function updateStatusView(u){
  if (!u || !u._ui) return;
  const ui=u._ui, scene=ui.scene;

  const effATK=u.ATK*atkMult(u), effSDM=u.SDM*sdmMult(u), effDEF=u.DEF*defMult(u);
  ui.statsTxt.setText(`ATK ${effATK.toFixed(1)}  ‚Ä¢  SDM ${effSDM.toFixed(1)}  ‚Ä¢  DEF ${effDEF.toFixed(1)}`);

  ui.statusNodes ||= []; for (const n of ui.statusNodes) n.destroy(); ui.statusNodes.length=0;

  const ORDER=['divine_shield','guard','shield_redirect','premonition','counter','poison','stun','taunt','blind','berserk','def_down','def_up','atk_up','sdm_up','marked','arcane_echo'];
  const present = ORDER.filter(key=>hasStatus(u,key)); if(!present.length) return;

  const ICON_SIZE=Math.max(8, parseInt(window.STATUS_ICON_SIZE??24,10)||24);
  const padX=Math.max(4,Math.round(ICON_SIZE*0.25)); const lineH=Math.max(18, ICON_SIZE+2);
  const startX=ui.badgeStartX??ui.baseX, startY=ui.badgeY??(ui.baseY+62), maxW=ui.badgeMaxW??(scene.PANEL_W-(ui.baseX*2));
  const labelFor=(key)=>(
    key==='def_up'?'DEF‚Üë': key==='def_down'?'DEF‚Üì': key==='atk_up'?'ATK‚Üë': key==='sdm_up'?'SDM‚Üë':
    key==='guard'?'GUARD': key==='divine_shield'?'Shield': key==='shield_redirect'?'Intercept':
    key==='marked'?'Marked': key==='premonition'?'FAST': key==='counter'?'Counter': key==='arcane_echo'?'Echo':
    key.charAt(0).toUpperCase()+key.slice(1)
  );

  let used=0,line=0;
  for (const key of present){
    const texKey=`status_${key}`; let node,w=ICON_SIZE;
    if (scene.textures.exists(texKey)){ node=scene.add.image(0,0,texKey).setOrigin(0,0); node.setDisplaySize(ICON_SIZE,ICON_SIZE); }
    else { const fontPx=Math.max(12,Math.round(ICON_SIZE*0.8)); node=scene.add.text(0,0,labelFor(key),{fontSize:`${fontPx}px`,color:'#dfe7ff'}); w=node.width; }
    if (used>0 && used+padX+w>maxW){ line++; if(line>1){ node.destroy(); continue; } used=0; }
    const x=startX+(used>0?padX:0)+used, y=startY+(line*lineH);
    ui.panel.add(node); node.setPosition(x,y); ui.statusNodes.push(node);
    if (STACKABLE.has(key)){ const n=countStacks(u,key); if(n>1){ const sTxt=scene.add.text(0,0,`√ó${n}`,{fontSize:`${Math.max(10,Math.round(ICON_SIZE*0.6))}px`,color:'#ffd37a'}); sTxt.setOrigin(1,1); sTxt.setPosition(x+ICON_SIZE-2,y+ICON_SIZE-2); ui.panel.add(sTxt); ui.statusNodes.push(sTxt); } }
    used += (used>0?padX:0) + w;
  }
}

/* ---------- end-of-round ticks & shrug ---------- */
const SHRUG_MESSAGES={ poison:(u)=>`${u.name} shrugs off the poison like it was nothing!`, stun:(u)=>`${u.name} snaps out of it and is no longer stunned!`, blind:(u)=>`${u.name} regains vision!`, berserk:(u)=>`${u.name}'s bloodlust wears off!`, def_down:(u)=>`${u.name} feels less vulnerable to attacks!` };
function tryShrug(u,key){
  const tgh=JOBS[u.job].TGH; const p=(CONFIG.SHRUG_BASE??0.05)+tgh*(CONFIG.SHRUG_TGH_FACTOR??0.005);
  if(chance(p)){ const before=u.status.length; u.status=u.status.filter(s=>s.key!==key);
    if(u.status.length!==before){ const msgFn=SHRUG_MESSAGES[key]; if(msgFn) appendLog(msgFn(u)); updateStatusView(u); }
    return true;
  } return false;
}

/* === CANONICAL ORDER HELPERS (host‚Üíguest, then by name) === */
function ensureUnitSides(){
  const mySide  = (PVP && PVP.role) || 'host';
  const oppSide = (mySide === 'host') ? 'guest' : 'host';
  for (const u of (player || [])) { if (u) u.side = mySide; }
  for (const u of (enemy  || [])) { if (u) u.side = oppSide; }
}

function canonicalKey(u){
  const side = u?.side || ((u?.team === 'player' ? PVP?.role : (PVP?.role === 'host' ? 'guest' : 'host')) || 'host');
  return `${side}|${u?.name || ''}`;
}

function canonicalUnits(){
  ensureUnitSides();
  const sideRank = { host: 0, guest: 1 };
  const all = [...(player || []), ...(enemy || [])];
  return all.slice().sort((a,b)=>{
    const sa = sideRank[a.side] ?? 0, sb = sideRank[b.side] ?? 0;
    if (sa !== sb) return sa - sb;
    const na = a.name || '', nb = b.name || '';
    return na.localeCompare(nb);
  });
}

function roundStateChecksum(){
  const all = canonicalUnits();
  const snap = all.map(u => ({
    k: canonicalKey(u),
    hp: u.hp|0,
    st: (u.status||[])
          .filter(s => s && s.key)
          .sort((a,b)=>a.key.localeCompare(b.key))
          .map(s => `${s.key}:${s.dur|0}`)
  }));
  const json = JSON.stringify(snap);
  return (fnv1a(json) >>> 0);
}

/* ---------- end-of-round ticks & shrug (canonical order) ---------- */
function endRoundTick(){
  const all = canonicalUnits();

  for (const u of all){
    if (!u.alive()) continue;

    // Poison ticks
    const p = u.status.find(s => s.key === 'poison');
    if (p && Array.isArray(p.data?.contributions) && p.data.contributions.length){
      const current = p.data.contributions.reduce((s,c)=>s+(c.amt||0),0);
      if (current>0){
        const dealt = Math.floor(current * (CONFIG.DAMAGE_GLOBAL||1));
        u.hp = clamp(u.hp - dealt, 0, u.maxHP);

        p.data.contributions = p.data.contributions
          .map(c=>({ amt: Math.floor(c.amt * 0.85) }))
          .filter(c=>c.amt >= 1);

        const totalLeft = p.data.contributions.reduce((s,c)=>s+c.amt,0);
        logGreen(`${u.name} takes ${dealt} poison damage (${totalLeft} total).`);
        u._refresh && u._refresh(); checkHPWarnings(u);

        if (p.data.contributions.length===0) removeStatusKey(u,'poison');
      }
    }

    // Decrement durations (except poison)
    for (const st of u.status){ if (st.key !== 'poison') st.dur--; }
    u.status = u.status.filter(s=>s.dur > 0);

    // Shrug checks in fixed order
    if (hasStatus(u,'poison'))   tryShrug(u,'poison');
    if (hasStatus(u,'stun'))     tryShrug(u,'stun');
    if (hasStatus(u,'blind'))    tryShrug(u,'blind');
    if (hasStatus(u,'berserk'))  tryShrug(u,'berserk');
    if (hasStatus(u,'def_down')) tryShrug(u,'def_down');

    updateStatusView(u);
  }
}


/* ---------- team accessor ---------- */
function teamArray(team){ return team==='player' ? player : enemy; }

/* ---------- core hit() ---------- */
function hit(a, t, opt={}, verb){
  if (hasStatus(a,'stun')){ appendLog(`${a.name} is stunned and cannot act.`); return {dealt:0,dodged:false,crit:false}; }

  const ability = opt.ability;
  const looksLikeAbility = ability && (ability.base || ability.statCoef!==undefined || ability.defPen!==undefined || ability.isBasic);
  let target=t;

  // Shieldwall redirect (first single-target hit)
  const wantsST = ability && ability.target==='enemy';
  if (wantsST && !opt._noRedirect && t && t.team){
    const pool=teamArray(t.team); const guardian=pool.find(u=>u!==t && u.alive() && hasStatus(u,'shield_redirect'));
    if (guardian){
      const st=guardian.status.find(s=>s.key==='shield_redirect'); if(st&&(st.data??(st.data={}))){
        st.data.remaining=(st.data.remaining??1)-1; if (st.data.remaining<=0) removeStatusKey(guardian,'shield_redirect');
      }
      appendLogHTML(`${guardian.name} <span style="color:#a7c4ff">intercepts</span> the blow for ${t.name}!`);
      target=guardian;
    }
  }

  const res = looksLikeAbility ? computeAbilityDamage(a,target,ability) : calcDamage(a,target,opt);
  const abilityName = (a._usingAbilityLabel || (verb ? verb : (ability ? ability.label : (opt.type==='mag'?'spell':'attack'))));

  if (res.dodged){ appendLogHTML(`${target.name} <span style="color:skyblue">dodges</span> ${a.name}‚Äôs ${abilityName}!`); return {dealt:0,dodged:true,crit:false}; }

  let dmgToApply=res.dmg;
  if (a._echoing) dmgToApply = Math.floor(dmgToApply * (a._echoMult || CONFIG.ECHO_MULT || 1.05));
  if (opt.dmgMult) dmgToApply = Math.floor(dmgToApply * opt.dmgMult);

  if (hasStatus(target,'divine_shield') && dmgToApply>0){ appendLogHTML(`${target.name} is protected by <span style="color:#ffd700">Divine Shield</span>! No damage taken.`); dmgToApply=0; }
  if (hasStatus(target,'marked') && dmgToApply>0){ dmgToApply=Math.floor(dmgToApply*(CONFIG.MARKED_MULT||1.5)); }
  if (hasStatus(target,'guard') && dmgToApply>0){
    const pctFromStatus=target.status.find(s=>s.key==='guard')?.data?.pct;
    const guardPct=Number.isFinite(pctFromStatus)?pctFromStatus:(window.GUARD_REDUCTION??0.5);
    const clamped=Math.max(0,Math.min(0.95,guardPct)); const reduced=Math.floor(dmgToApply*(1-clamped));
    const saved=dmgToApply-reduced; dmgToApply=reduced; if (saved>0) appendLogHTML(`${target.name} <span style="color:#a7c4ff">guards</span>, mitigating ${saved} damage.`);
  }

  target.hp = clamp(target.hp - dmgToApply, 0, target.maxHP);
  target._refresh && target._refresh();
  checkHPWarnings(target);

  if (abilityName.toLowerCase()==='attack'){
    if (res.crit) appendLogHTML(`${a.name}‚Äôs attack lands a <span style="color:gold">critical strike</span>! ${target.name} takes ${dmgToApply} damage.`);
    else          appendLog(`${a.name} attacks ${target.name} for ${dmgToApply} damage.`);
  } else {
    if (res.crit) appendLogHTML(`${a.name}‚Äôs ${abilityName} lands a <span style="color:gold">critical strike</span>! ${target.name} takes ${dmgToApply} damage.`);
    else          appendLog(`${a.name} uses ${abilityName}. ${target.name} takes ${dmgToApply} damage.`);
  }

  if (dmgToApply>0 && target.hp<=0){
  appendLogHTML(`<span style="color:#ff6b6b">‚ò† ${target.name} is down!</span>`);
  if (target._ui){ target._refresh && target._refresh(); } // draw KO X via _refresh
}


  if (ability?.isBasic && dmgToApply>0 && target.alive()){ maybeProcOnBasic(a,target); }

  if (!opt._noCounter && target.alive() && a.alive() && hasStatus(target,'counter')){
    const counter={label:'Counter', type:'phys', target:'enemy', base:{min:8,max:14}, scalesWith:'ATK', statCoef:(CONFIG.COUNTER_COEF||0.30)};
    const oldLabel=target._usingAbilityLabel; target._usingAbilityLabel='Counter';
    hit(target,a,{ability:counter,_noCounter:true,_noRedirect:true},'counterstrikes'); target._usingAbilityLabel=oldLabel;
  }
  return {dealt:dmgToApply,dodged:false,crit:res.crit};
}

/* ===== PART 3/4 ‚Äî Parties, UI, Scene, Round ===== */

/* ---------- Parties & round state ---------- */
function pickRandomJobs(n){ const pool=[...ALL_CLASSES], picks=[]; for(let i=0;i<n&&pool.length>0;i++){ const idx=Math.floor(rand()*pool.length); picks.push(pool[idx]); pool.splice(idx,1);} return picks;}
function createParty(teamName){ return pickRandomJobs(3).map(job=>makeUnit(job,teamName)); }

let player = [];   // PvP: start empty until draft completes
let enemy  = [];

let selectingIndex = 0;
let playerChoices  = [];
let enemyChoices   = [];
let roundNumber    = 1;

function resetRoundState(){
  selectingIndex = 0;
  playerChoices  = [];
  enemyChoices   = [];
  _pendingAbility = null;
  _pendingTargetPick = false;
  _pendingAbilityTarget = null;
}

/* ---------- selection helpers ---------- */
const SPEED_RANK = { fast:0, normal:1, slow:2 };
const allAlive = (arr)=> arr.filter(u=>u.alive());
function currentActor(){ const alive = player.filter(u => u.alive()); return alive[selectingIndex] || null; }

function setTopBarTitle(text, color = '#e8e8f0'){
  if (!topLeftEl) return;
  topLeftEl.textContent = text;
  topLeftEl.style.color = color;
}

function setTopBarLobby(){
  setTopBarTitle('Realm of Shinobi: Tournament of Legends', '#a7c4ff');
}

/* ---------- target pick UI ---------- */
let _pendingAbility = null;
let _pendingTargetPick = false;
let _pendingAbilityTarget = null;

function updateTopBarForCurrentSelection(){
    // If we‚Äôre in the lobby, force the title (no round text)
  if (PVP && PVP.phase === 'idle'){
    setTopBarLobby();
    return;
  }
const actor = currentActor();
  if (!actor){ topLeftEl.textContent = `Round ${roundNumber} ‚Äî Waiting‚Ä¶`; return; }

  if (_pendingTargetPick && _pendingAbility){
  const tgtWord = _pendingAbilityTarget==='ally' ? 'an ally' : 'an enemy';
  const abLabel = _pendingAbility.label || 'ability';
  topLeftEl.textContent = `Round ${roundNumber} ‚Äî Select ${tgtWord} for ${actor.name}'s ${abLabel}`;
  return;
}


  const ta = actor.status?.find(s=>s.key==='taunt' && s.dur>0 && s.data?.taunter?.alive());
  if (ta){ topLeftEl.textContent = `Round ${roundNumber} ‚Äî ${actor.name} is taunted: must Attack ${ta.data.taunter.name}`; return; }

  topLeftEl.textContent = `Round ${roundNumber} ‚Äî Choose action for ${actor.name}`;
}

function enterLobbyUI(){
  // Top bar title for the lobby
  if (topLeftEl) topLeftEl.textContent = 'Realm of Shinobi: Tournament of Legends';

  // Clear action bars
  if (typeof clearActionBar === 'function') clearActionBar();
  const right = document.getElementById('action-bar-right');
  if (right) right.textContent = '';

  // Clear any leftover unit rows from the last battle (keep background)
  if (sceneRef){
    try{
      sceneRef.playerCol && sceneRef.playerCol.removeAll(true);
      sceneRef.enemyCol  && sceneRef.enemyCol.removeAll(true);
    }catch(_){}
  }
}

/* ---------- enemy AI (SP only, unused in PvP) ---------- */
function makeEnemyChoices(){
  enemyChoices=[]; const eAlive=allAlive(enemy), pAlive=allAlive(player);
  for (const a of eAlive){
    if (hasStatus(a,'berserk')){
      const everyoneElse=[...pAlive,...eAlive].filter(x=>x!==a);
      const tgt=everyoneElse.length?everyoneElse[(rand()*everyoneElse.length)|0]:null;
      enemyChoices.push({ actor:a, ability:{label:'Berserk Attack',speed:'fast',type:'phys',target:'enemy',
        use:(aa,tt)=>{ if(tt) hit(aa,tt,{},'frenzies at'); } }, target:tgt });
      continue;
    }
    const ta=a.status.find(s=>s.key==='taunt'&&s.dur>0&&s.data?.taunter?.alive());
    if (ta){ const basic=abilitiesFor(a).find(x=>x.isBasic||(x.label&&x.label.toLowerCase()==='attack')); if(basic){
      enemyChoices.push({ actor:a, ability:{label:'Forced Attack',speed:'normal',target:'enemy',
        use:function(aa,tt){ aa._usingAbilityLabel=basic.label; const r=hit(aa,tt,{ability:basic}); aa._usingAbilityLabel=undefined; return r; } }, target:ta.data.taunter });
      continue; } }
    const abil=choice(abilitiesFor(a)); let tgt=null;
    if (abil.target==='enemy') tgt=choice(pAlive); else if (abil.target==='ally') tgt=choice(eAlive); else if (abil.target==='self') tgt=a;
    enemyChoices.push({actor:a,ability:abil,target:tgt});
  }
}

/* ---------- seed helpers ---------- */
function fnv1a(str){ let h=0x811c9dc5>>>0; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=Math.imul(h,0x01000193)>>>0; } return h>>>0; }

function canonicalKey(u){
  // Use network-side + name so it‚Äôs the same on both clients
  const side = u?.side || (u?.team === 'player'
    ? (PVP?.role || 'host')
    : (PVP?.role === 'host' ? 'guest' : 'host'));
  return `${side}|${u?.name || ''}`;
}

/* ---------- canonicalize choices for seeding ---------- */
function canonicalizeChoices(mine, opp){
  const norm=arr=>(arr||[]).map(c=>({a:c.actorName||'', b:c.abilityLabel||'', t:c.targetName||''}));
  const A=norm(mine).map(x=>`M|${x.a}|${x.b}|${x.t}`); const B=norm(opp).map(x=>`O|${x.a}|${x.b}|${x.t}`);
  return A.concat(B).sort().join(';');
}

/* ---------- resolve (simultaneous) ---------- */
async function resolveSimultaneous(){
  const q=[...playerChoices, ...enemyChoices];

    // unified speed helper (define **once**)
  const effSpeed = (c) =>
    hasStatus(c.actor, 'premonition') ? SPEED_RANK.fast : (SPEED_RANK[c.ability.speed] ?? 1);

  // canonical action order: speed ‚Üí QKN (desc) ‚Üí stable tiebreaker
  q.sort((A, B) => {
    const sa = effSpeed(A), sb = effSpeed(B);
    if (sa !== sb) return sa - sb;

    const qa = JOBS[A.actor.job].QKN, qb = JOBS[B.actor.job].QKN;
    if (qa !== qb) return qb - qa; // higher QKN first

    // final, fully-deterministic tiebreaker across clients
    const ka = canonicalKey(A.actor), kb = canonicalKey(B.actor);
    return ka.localeCompare(kb);
  });


  for (const step of q){
    const { actor } = step;
    if (!actor.alive()){ await sleep(SLEEP_TINY_MS); continue; }

    // berserk at resolve
    if (hasStatus(actor,'berserk')){
      const pool=[...player.filter(u=>u.alive()), ...enemy.filter(u=>u.alive())].filter(x=>x!==actor);
      const tgt=pool.length?pool[(rand()*pool.length)|0]:null;
      if (tgt){ const basic=abilitiesFor(actor).find(a=>a.isBasic||(a.label&&a.label.toLowerCase()==='attack'));
        if (basic&&typeof basic.use==='function'){ actor._usingAbilityLabel=basic.label; basic.use.call(basic,actor,tgt); actor._usingAbilityLabel=undefined; }
        else { hit(actor,tgt,{type:(actor.kind==='mag'?'mag':'phys'), scale:1.0 }, 'attacks'); }
      } else { appendLog(`${actor.name} rages in place with no target!`); }
      await sleep(ACTION_DELAY_MS); continue;
    }

    // stun
    if (hasStatus(actor,'stun')){
      if (step.ability && step.ability.speed==='slow') appendLog(`${actor.name}'s ${step.ability.label} is interrupted!`);
      else appendLog(`${actor.name} is stunned and loses their action.`);
      await sleep(ACTION_DELAY_MS); continue;
    }

    // taunt recheck
    const ta=actor.status.find(s=>s.key==='taunt'&&s.dur>0&&s.data?.taunter?.alive());
    if (!ta){ const deadTa=actor.status.find(s=>s.key==='taunt'&&s.dur>0&&!s.data?.taunter?.alive?.()); if(deadTa){ actor.status=actor.status.filter(s=>s!==deadTa); updateStatusView(actor);} }
    else {
      const basic=abilitiesFor(actor).find(x=>x.isBasic||(x.label&&x.label.toLowerCase()==='attack'));
      if (basic && ta.data.taunter.alive()){
        appendLog(`${actor.name} is taunted and must attack ${ta.data.taunter.name}!`);
        actor._usingAbilityLabel=basic.label;
        if (typeof basic.use==='function') basic.use.call(basic,actor,ta.data.taunter); else hit(actor,ta.data.taunter,{ability:basic});
        actor._usingAbilityLabel=undefined; await sleep(ACTION_DELAY_MS); continue;
      }
    }

    // normal exec
    const { ability, target } = step;
    if (ability.label==='Attack' && actor.kind==='phys' && hasStatus(actor,'blind') && rand()<0.5){ appendLog(`${actor.name} is blinded and whiffs!`); await sleep(ACTION_DELAY_MS); continue; }
    // Target validity (permit dead ally if ability allows it, e.g. Resurrection)
if (['enemy','ally'].includes(ability.target)){
  const allowDead = !!ability.allowDeadTarget;
  if (!target || (!target.alive() && !allowDead)) {
    appendLog(`${actor.name}'s ${ability.label} misses (invalid target).`);
    await sleep(ACTION_DELAY_MS);
    continue;
  }
}


    actor._usingAbilityLabel=ability.label; actor._usingAbilityMeta=ability;
    const allies=actor.team==='player'?player:enemy; const foes=actor.team==='player'?enemy:player;

    const doInvoke=async()=>(
      typeof ability.use==='function'
        ? ability.use.call(ability, actor,
            ability.target==='enemy'       ? target :
            ability.target==='ally'        ? target :
            ability.target==='self'        ? actor :
            ability.target==='all-enemies' ? foes.filter(u=>u.alive()) :
            ability.target==='all-allies'  ? allies.filter(u=>u.alive()) :
            null)
        : null
    );

    if (hasStatus(actor,'arcane_echo') && getAbilityType(actor,ability)==='mag' && !actor._echoing){
      await doInvoke();
      appendLogHTML(`${actor.name}'s <span style="color:#a7c4ff">Arcane Echo</span> repeats ${ability.label}!`);
      actor._echoing=true; actor._echoMult=(CONFIG.ECHO_MULT||1.05);
      await sleep(ACTION_STEP_DELAY_MS);
      await doInvoke();
      actor._echoing=false; actor._echoMult=1; removeStatusKey(actor,'arcane_echo');
    } else { await doInvoke(); }

    if (hasStatus(actor,'blind') && getAbilityType(actor,ability)==='phys' && rand()<0.5){ appendLog(`${actor.name} is blinded and whiffs!`); }

    await sleep(ACTION_DELAY_MS);
  }

  endRoundTick();

  await sleep(ROUND_END_DELAY_MS);

  const pAlive=player.filter(u=>u.alive()), eAlive=enemy.filter(u=>u.alive());
  if (eAlive.length===0){ appendLog('üèÜ Victory!'); return 'win'; }
  if (pAlive.length===0){ appendLog('üíÄ Defeat.');  return 'lose'; }
  return 'continue';
}

/* ---------- action bar (final) ---------- */
function renderActionBarForCurrent(){
// If I'm waiting for opponent in PvP, show a small waiting stub instead of inputs
if (PVP && PVP.phase === 'battle' && PVP.waitingForOpp) {
  actionButtonsEl.innerHTML = '';
  actionPromptEl.textContent = `Round ${roundNumber} ‚Äî Waiting for opponent‚Ä¶`;
  const stub = document.createElement('div');
  stub.style.cssText = 'opacity:.85;font-size:12px;text-align:center;padding:8px;';
  stub.textContent = 'Choices submitted. Waiting for the other side...';
  actionButtonsEl.appendChild(stub);
  return;
}

  if (!actionButtonsEl || !actionPromptEl) initActionBarShell();
  actionButtonsEl.innerHTML='';

  const actor=currentActor(); if(!actor){ actionPromptEl.textContent=''; return; }
  actionPromptEl.textContent=`Choose action for ${actor.name}`;

  const makeButton = (ability) => {
  const btn = document.createElement('button');
  btn.className = 'action-btn';

  const s = ability.speed || 'normal';
  const on = { fast:3, normal:2, slow:1 }[s] ?? 2;

  btn.innerHTML = `
    <div class="btn-inner">
      <div class="text">
        <div class="label">${ability.label}</div>
        <div class="desc">${ability.desc || ''}</div>
      </div>
      <div class="speed ${s}" title="${s}">
        <span class="dot ${on >= 1 ? '' : 'off'}"></span>
        <span class="dot ${on >= 2 ? '' : 'off'}"></span>
        <span class="dot ${on >= 3 ? '' : 'off'}"></span>
      </div>
    </div>
  `;

  btn.onclick = () => {
    _pendingAbility = ability;
    if (ability.target === 'enemy' || ability.target === 'ally') {
      _pendingTargetPick = true;
      _pendingAbilityTarget = ability.target;
    } else {
      _pendingTargetPick = false;
      _pendingAbilityTarget = null;
      confirmChoice(null);
    }
    updateTopBarForCurrentSelection();
  };

  return btn;
};

  const raw=abilitiesFor(actor)||[]; const isAttack=a=>a&&(a.isBasic||(a.label&&a.label.toLowerCase()==='attack'));
  const attack=raw.find(isAttack); const others=raw.filter(a=>!isAttack(a));
  const rank={fast:0,normal:1,slow:2}; others.sort((a,b)=>(rank[a.speed]??1)-(rank[b.speed]??1)||(a.label||'').localeCompare(b.label||''));

  const picks=[]; if(attack) picks.push(attack); for(const ab of others){ if(picks.length>=5) break; picks.push(ab); }
  for (let i=0;i<5;i++){ const node=picks[i]?makeButton(picks[i]):(()=>{const ph=document.createElement('button'); ph.className='action-btn placeholder'; ph.disabled=true; ph.innerHTML=`<div class="label">Empty</div>`; return ph;})(); actionButtonsEl.appendChild(node); }

  const guardAbility = {
  label:'Guard',
  desc:'Reduce damage taken this round.',
  speed:'fast',            // <-- gives it 3 dots
  type:'phys',
  target:'self',
  isGuard:true,
  use:(a)=>{
    const pct = (window.GUARD_REDUCTION ?? 0.5);
    pushStatus(a, { key:'guard', dur:1, data:{ pct } });
    appendLog(`${a.name} braces behind their guard.`);
  }
};
const guardBtn = makeButton(guardAbility);
actionButtonsEl.appendChild(guardBtn);

}

/* ---------- confirm (SP version) ---------- */
async function confirmChoice(target){
  const actor=currentActor(); if(!actor) return;
  if (!actor.alive()){
    appendLog(`${actor.name} is defeated and cannot act.`); _pendingAbility=null;
_pendingTargetPick = false;
_pendingAbilityTarget = null;
_pendingAbility = null;
    const alive=player.filter(u=>u.alive()); selectingIndex=Math.min(selectingIndex+1, alive.length);
    updateTopBarForCurrentSelection(); renderActionBarForCurrent(); return;
  }
  if (!_pendingAbility){ appendLog('Choose an ability first.'); return; }

  if ((_pendingAbility.target==='enemy'||_pendingAbility.target==='ally')) {
  const allowDead = !!_pendingAbility.allowDeadTarget;
  if (!target || (!target.alive() && !allowDead)) {
    appendLog('No valid target.'); 
    _pendingTargetPick = true; 
    updateTopBarForCurrentSelection(); 
    return;
  }
}

  const ta=actor.status.find(s=>s.key==='taunt'&&s.dur>0&&s.data?.taunter?.alive?.());
  if (ta){ const isBasic=a=>a&&(a.isBasic||(a.label&&a.label.toLowerCase()==='attack')); const basic=abilitiesFor(actor).find(isBasic);
    if (basic && ta.data.taunter.alive()){ appendLog(`${actor.name} is taunted and must attack ${ta.data.taunter.name}!`);
      _pendingAbility=basic; _pendingTargetPick=false; _pendingAbilityTarget=null; target=ta.data.taunter; } }

  const ability=_pendingAbility; _pendingAbility=null;
  playerChoices.push({ actor, ability, target });

  const alive=player.filter(u=>u.alive()); selectingIndex++;

_pendingTargetPick = false;
_pendingAbilityTarget = null;
_pendingAbility = null;

  if (selectingIndex >= alive.length){
    sendMyRoundChoices();
    if (Array.isArray(PVP.roundBuf.opp[roundNumber])){ tryResolveRoundWithBothSides(roundNumber); }
    if (typeof showRightWaitHint==='function') showRightWaitHint();
    if (topLeftEl) topLeftEl.textContent=`Round ${roundNumber} ‚Äî Waiting for opponent‚Ä¶`;
    return;
  }

  updateTopBarForCurrentSelection(); renderActionBarForCurrent();
}

/* ---------- Phaser Scene ---------- */
let game = null;
let sceneRef = null;

class GameScene extends Phaser.Scene{
  constructor(){ super('Game'); }

  preload(){
    const bgUrl = (window.ARENA_BG_URL && window.ARENA_BG_URL.trim()) ? window.ARENA_BG_URL.trim() : '';
    if (bgUrl){
      this.load.setCORS('anonymous');
      this.load.image('arena_bg', bgUrl);
    }
    const base = (window.SPRITE_BASE_URL || 'https://raw.githubusercontent.com/krezt/tol-assets/main').replace(/\/+$/,'');
    if (base){
      this.load.setCORS('anonymous');
      const JOB_LIST = (Array.isArray(ALL_CLASSES) && ALL_CLASSES.length) ? ALL_CLASSES :
        ['Warrior','Barbarian','Rogue','Cleric','Mage','Paladin','Archer','Monk','Necromancer','Mystic'];
      for (const job of JOB_LIST){
        this.load.image(`portrait_${job}`, `${base}/portraits/${encodeURIComponent(job)}.png`);
      }
      const STATUS_KEYS = ['poison','stun','taunt','blind','berserk','def_down','def_up','atk_up','sdm_up','guard','marked','premonition','arcane_echo','divine_shield','shield_redirect','counter'];
      for (const k of STATUS_KEYS){
        this.load.image(`status_${k}`, `${base}/status/${k}.png`);
      }
    }
  }

  create(){
    sceneRef = this;

    // layout constants
    this.PANEL_W = 380; this.PANEL_H = 120; this.PAD_X = 10; this.PAD_Y = 6;
    this.HPBAR_W = this.PANEL_W - (this.PAD_X*2) - 70;
    this.MARGIN_L = 20; this.MARGIN_R = 20; this.GAP_MIN = 48;
    this.Y_START = 80; this.ROW_H = this.PANEL_H + 8;

    // background
    if (this.textures.exists('arena_bg')){
      this.bgImage = this.add.image(0,0,'arena_bg').setOrigin(0.5,0.5).setDepth(-120);
    } else {
      this.bgSolid = this.add.rectangle(0,0,this.scale.width,this.scale.height,0x0f0f13,1).setOrigin(0,0).setDepth(-120);
    }

    // headers
    this.nameStyle = { fontSize:'18px', fontStyle:'bold', color:'#ffffff' };
    this.titleTxt  = this.add.text(20,20,'ROS: Tournament of Legends',{fontSize:'24px', fontStyle:'bold'});
    this.playerHdr = this.add.text(0,54,(PVP.playerName||'You'),      {fontSize:'18px', fontStyle:'bold', color:'#ffffff'});
    this.enemyHdr  = this.add.text(0,54,(PVP.opponentName||'Opponent'),{fontSize:'18px', fontStyle:'bold', color:'#ffffff'});
    const headerAlpha = 0.80;
    this.playerHdrBg = this.add.rectangle(0,0,10,10,0x000000, headerAlpha).setOrigin(0,0).setDepth(-1);
    this.enemyHdrBg  = this.add.rectangle(0,0,10,10,0x000000, headerAlpha).setOrigin(0,0).setDepth(-1);

    // live header name updater
    this.updateHeaderNames = () => {
      const mine = PVP?.myName || 'You';
      const opp  = PVP?.opponentName || 'Opponent';
      this.playerHdr.setText(mine);
      this.enemyHdr.setText(opp);
    };
    this.updateHeaderNames();

    // columns/containers
    this.playerCol = this.add.container(0,0);
    this.enemyCol  = this.add.container(0,0);
    this._enemyRowClickers = [];
    this._allyRowClickers  = [];

    // 1) hydrate units from picks when scene starts (covers post-restart race)
    if ((!Array.isArray(player) || player.length === 0) && Array.isArray(PVP?.picksMe) && PVP.picksMe.length){
      player = PVP.picksMe.map(job => makeUnit(job, 'player'));
    }
    if ((!Array.isArray(enemy) || enemy.length === 0) && Array.isArray(PVP?.picksOpp) && PVP.picksOpp.length){
      enemy = PVP.picksOpp.map(job => makeUnit(job, 'enemy'));
    }
ensureUnitSides();

    // DBG: log counts so you can see what the scene sees
    appendLog(`[DBG] Scene.create ‚Äî player=${player.length}, enemy=${enemy.length}, picksMe=${PVP?.picksMe?.length||0}, picksOpp=${PVP?.picksOpp?.length||0}`);

    const texExists = (k) => this.textures.exists(k);

    // ---------- draw a single unit panel ----------
    const drawPanel = (parent, u, colX, topY, isEnemy) => {
      const panel = this.add.container(colX, topY); parent.add(panel);
      const bg = this.add.rectangle(0,0,this.PANEL_W,this.PANEL_H,0x1c1f26,0.55).setOrigin(0,0);
      const bd = this.add.rectangle(0,0,this.PANEL_W,this.PANEL_H).setOrigin(0,0).setStrokeStyle(1,0x3b4252,1);
      panel.add([bg,bd]);

      const x = this.PAD_X, y = this.PAD_Y;

      const portraitKey = `portrait_${u.job}`;
      let nameOffset = 0; let hpBarX = x, hpBarW = this.HPBAR_W;
      if (texExists(portraitKey)){
        const pImg = this.add.image(x,y,portraitKey).setOrigin(0,0);
        pImg.setDisplaySize(48,48);
        panel.add(pImg);
        nameOffset = 48 + 8; hpBarX = x + nameOffset;
        hpBarW = Math.max(80, this.PANEL_W - (this.PAD_X*2) - 70 - nameOffset);
      }

      const name = this.add.text(x+nameOffset, y, u.name, this.nameStyle);
      const hpTxt= this.add.text(this.PANEL_W-this.PAD_X, y, `HP ${u.hp}/${u.maxHP}`,
                      {fontSize:'18px', fontStyle:'bold', color:'#dfe7ff'}).setOrigin(1,0);
      panel.add([name,hpTxt]);

      const hpBarY = y+26;
      const hpBg = this.add.rectangle(hpBarX, hpBarY, hpBarW, 12, 0x2b2f3a).setOrigin(0,0.5);
      const fg   = this.add.rectangle(hpBarX, hpBarY, hpBarW, 12, 0x47d16a).setOrigin(0,0.5);
      panel.add([hpBg, fg]);

      const statsTxt = this.add.text(x+nameOffset, hpBarY+18, '', {fontSize:'14px', color:'#dfe7ff'});
      panel.add(statsTxt);

      const statusNodes = [];
      u._ui = {
        panel, fg, txt:hpTxt, statusNodes, statsTxt, baseX:x, baseY:y, scene:this,
        nameOffset, hpBarWidth:hpBarW,
        badgeStartX:x+nameOffset, badgeY:statsTxt.y+16,
        badgeMaxW:Math.max(80, this.PANEL_W-(this.PAD_X*2)-nameOffset)
      };

      // refresh visuals
      u._refresh = () => {
        const p = u.hp / u.maxHP;
        u._ui.fg.width = Math.max(1, Math.floor(u._ui.hpBarWidth * Math.max(0, p)));
        u._ui.fg.fillColor = p > 0.5 ? 0x47d16a : (p > 0.25 ? 0xffc857 : 0xff5d6c);
        u._ui.txt.setPosition(this.PANEL_W - this.PAD_X, u._ui.baseY);
        u._ui.txt.setText(`HP ${Math.max(0, u.hp)}/${u.maxHP}`);

        const isDead = u.hp <= 0;
        u._ui.panel.setAlpha(isDead ? 0.55 : 1);

        // KO cross overlay
        if (isDead) {
          if (!u._ui._deadCross) {
            const g = this.add.graphics();
            g.lineStyle(2, 0xff6b6b, 0.95);
            const pad = 6, w = this.PANEL_W, h = this.PANEL_H;
            g.strokeLineShape(new Phaser.Geom.Line(pad, pad, w - pad, h - pad));
            g.strokeLineShape(new Phaser.Geom.Line(w - pad, pad, pad, h - pad));
            u._ui.panel.add(g);
            u._ui._deadCross = g;
          }
        } else {
          if (u._ui._deadCross) { u._ui._deadCross.destroy(); u._ui._deadCross = null; }
        }

        if (!isDead && u._ui._struck) { u._ui._struck.destroy(); u._ui._struck = null; }

        updateStatusView(u);
      };
      u._refresh();

      // click to target
      const hitBox = this.add.rectangle(this.PANEL_W/2, 24, this.PANEL_W, 48, 0x000000, 0)
                        .setInteractive({useHandCursor:true});
      panel.add(hitBox);
      hitBox.on('pointerover', ()=>{ name.setStyle({color:'#a7c4ff', fontStyle:'bold'}); });
      hitBox.on('pointerout',  ()=>{ name.setStyle({color:'#ffffff', fontStyle:'bold'}); });
      hitBox.on('pointerdown', ()=>{
        if (_pendingTargetPick && _pendingAbility){
          const wantEnemy = (_pendingAbilityTarget === 'enemy');
          const isValid   = (wantEnemy && isEnemy) || (!wantEnemy && !isEnemy);
          if (isValid) confirmChoice(u);
          else appendLog(`That target is not valid for ${_pendingAbility.label}.`);
        }
      });

      if (isEnemy) this._enemyRowClickers.push({rect:hitBox,label:name});
      else         this._allyRowClickers.push({rect:hitBox,label:name});
    }; // end drawPanel

    // ---------- SINGLE rebuild helper ----------
    this.rebuildPanels = () => {
      this.playerCol.removeAll(true);
      this.enemyCol.removeAll(true);
      this._enemyRowClickers = [];
      this._allyRowClickers  = [];

      for (let i = 0; i < player.length; i++) {
        drawPanel(this.playerCol, player[i], 0, this.Y_START + i * this.ROW_H, false);
      }
      for (let i = 0; i < enemy.length; i++) {
        drawPanel(this.enemyCol,  enemy[i],  0, this.Y_START + i * this.ROW_H, true);
      }

      for (const u of [...player, ...enemy]) { if (u && u._refresh) u._refresh(); }

      this.reflow();
    };

    // 2) initial render now that helper exists
    this.rebuildPanels();

    // 3) last-ditch fallback: if still empty, force hydrate & redraw
    if ((player.length === 0 || enemy.length === 0) &&
        (Array.isArray(PVP?.picksMe) && PVP.picksMe.length) &&
        (Array.isArray(PVP?.picksOpp) && PVP.picksOpp.length)) {
      appendLog('[DBG] Forcing hydrate from picks after restart‚Ä¶');
      player = PVP.picksMe.map(job => makeUnit(job, 'player'));
      enemy  = PVP.picksOpp.map(job => makeUnit(job, 'enemy'));
      this.rebuildPanels();
    }

    // layout, resize
    this.reflow();
    this.scale.on('resize', ()=> this.reflow());

    // round UI (safe even if empty‚Äîbuttons will be hidden by waiting state)
    roundNumber = 1;
    resetRoundState();
    updateTopBarForCurrentSelection();
    renderActionBarForCurrent();
  }

  updateBackgroundLayout(){
    const W = this.scale.width, H = this.scale.height;
    if (this.bgImage){
      const tex = this.textures.get('arena_bg').getSourceImage();
      const s = Math.max(W/tex.width, H/tex.height);
      this.bgImage.setPosition(W/2,H/2).setScale(s);
    } else if (this.bgSolid){
      this.bgSolid.setPosition(0,0);
      this.bgSolid.width = W; this.bgSolid.height = H;
    }
    const padX=8,padY=3;
    this.playerHdrBg.setPosition(this.playerHdr.x-padX, this.playerHdr.y-padY);
    this.playerHdrBg.width  = this.playerHdr.width  + padX*2;
    this.playerHdrBg.height = this.playerHdr.height + padY*2;
    this.enemyHdrBg.setPosition(this.enemyHdr.x-padX, this.enemyHdr.y-padY);
    this.enemyHdrBg.width  = this.enemyHdr.width  + padX*2;
    this.enemyHdrBg.height = this.enemyHdr.height + padY*2;
  }

  reflow(){
    const W = this.scale.width;
    const usable = Math.max(640, W);
    this.PANEL_W = (usable < 1000) ? 340 : 380;
    this.HPBAR_W = this.PANEL_W - (this.PAD_X*2) - 70;

    for (const u of [...player, ...enemy]){
      if (!u || !u._ui) continue;
      const localHPW = this.PANEL_W - (this.PAD_X*2) - 70 - (u._ui.nameOffset || 0);
      u._ui.hpBarWidth = Math.max(80, localHPW);
    }

    const LEFT_X = this.MARGIN_L;
    const RIGHT_X = Math.max(LEFT_X + this.PANEL_W + this.GAP_MIN, usable - (this.PANEL_W + this.MARGIN_R));
    this.playerHdr.setPosition(LEFT_X,54);
    this.enemyHdr.setPosition(RIGHT_X,54);
    this.playerCol.setPosition(LEFT_X,0);
    this.enemyCol.setPosition(RIGHT_X,0);

    if (typeof this.updateHeaderNames === 'function') this.updateHeaderNames();

    for (const u of [...player, ...enemy]){ if (u && u._refresh) u._refresh(); }

    this.updateBackgroundLayout();
  }
}



/* ===== Lobby overlay in battlefield (DOM, not Phaser) ===== */
function unmountLobbyInField(){
  const ov = document.getElementById('lobby-overlay');
  if (ov) ov.remove();
}

function mountLobbyInField(){
  unmountLobbyInField();
  const root = document.getElementById('battlefield');
  if (!root) return;
  root.style.position = 'relative';

  const ov = document.createElement('div');
  ov.id = 'lobby-overlay';
  Object.assign(ov.style, {
    position:'absolute', inset:'8px',
    background:'rgba(10,12,16,0.92)', border:'2px solid #3a4257', borderRadius:'8px',
    color:'#e8e8f0', zIndex: 5, display:'flex', flexDirection:'column', gap:'10px', padding:'12px'
  });

  // Header + name
  const header = el('div', { style:{ display:'flex', alignItems:'center', justifyContent:'space-between', gap:'8px' }});
  header.appendChild(el('div', { style:{ fontWeight:'800', fontSize:'20px' }}, 'PvP Lobby'));
  const nameWrap = el('div', { style:{ display:'flex', gap:'6px', alignItems:'center' }});
  nameWrap.appendChild(el('label', { style:{ fontSize:'12px', opacity:.9 }}, 'Your name:'));
  const nameInput = el('input', { id:'lobby-name', placeholder:'Type your name', value:(PVP.myName||PVP.playerName||'') });
  Object.assign(nameInput.style, { background:'#22314b', color:'#fff', border:'1px solid #4a5a7a', borderRadius:'4px', padding:'6px 8px', minWidth:'160px' });
  const saveBtn = el('button', { class:'action-btn', style:{ padding:'6px 10px' }}, el('div', { class:'label', style:{ fontSize:'14px' }}, 'Save'));
  header.appendChild(nameWrap);
  nameWrap.appendChild(nameInput); nameWrap.appendChild(saveBtn);
  ov.appendChild(header);

  // Tip + error
  const tip  = el('div', { id:'lobby-tip',  style:{ fontSize:'12px', opacity:.85, textAlign:'center' }}, 'Tip: share the room ID so friends can join.');
  const err  = el('div', { id:'lobby-error',style:{ fontSize:'12px', color:'#ffb3b3', textAlign:'center', display:'none' }}, '');
  ov.appendChild(tip); ov.appendChild(err);

  // Controls: Create room, Quick Match, Join by ID
  const controls = el('div', { style:{ display:'flex', gap:'8px', flexWrap:'wrap', justifyContent:'center' }});
  const mkBtn = (label, onClick) => {
    const b = el('button', { class:'action-btn', style:{ padding:'8px 12px' }}, el('div', { class:'label', style:{ fontSize:'16px' }}, label));
    b.onclick = onClick; return b;
  };
  const createBtn = mkBtn('Create Room', async ()=>{ await connectWS(); send({ kind:'create_room' }); });
  const quickBtn  = mkBtn('Quick Match', async ()=>{ await connectWS(); send({ kind:'queue' }); });
  controls.appendChild(createBtn); controls.appendChild(quickBtn);

  // Join by ID
  const joinWrap = el('div', { style:{ display:'flex', gap:'6px', alignItems:'center', justifyContent:'center' }});
  const joinInp  = el('input', { id:'lobby-join-id', placeholder:'Enter room ID' });
  Object.assign(joinInp.style, { background:'#22314b', color:'#fff', border:'1px solid #4a5a7a', borderRadius:'4px', padding:'6px 8px', minWidth:'140px' });
  const joinBtn  = mkBtn('Join', async ()=>{ const id=(joinInp.value||'').trim(); if(!id) return; await connectWS(); send({ kind:'join_room', id }); });
  joinWrap.appendChild(joinInp); joinWrap.appendChild(joinBtn);

  ov.appendChild(controls);
  ov.appendChild(joinWrap);

  // Status after create
  const roomStatus = el('div', { id:'lobby-room-status', style:{ display:'none', textAlign:'center', fontSize:'13px' }});
  ov.appendChild(roomStatus);

  // List
  const list = el('div', { id:'lobby-rooms', style:{ marginTop:'6px', overflow:'auto', flex:'1 1 auto', borderTop:'1px solid #3a4257', paddingTop:'8px' }});
  ov.appendChild(list);

  root.appendChild(ov);
enterLobbyUI();

  // Update the top bar while in lobby
  setTopBarLobby();


  // Save name handlers
  const saveName = () => {
    const v = (nameInput.value || '').trim().slice(0,16);
    if (!v) return;
    PVP.myName = v; PVP.playerName = v;
    connectWS().then(()=> send({ kind:'set_name', name:v }));
    if (sceneRef && sceneRef.updateHeaderNames) sceneRef.updateHeaderNames();
  };
  saveBtn.onclick = saveName;
  nameInput.addEventListener('keydown', e => { if (e.key==='Enter') { e.preventDefault(); saveName(); }});
  nameInput.addEventListener('blur', saveName);

  // Ask for rooms + periodic refresh
  connectWS().then(()=>{
    send({ kind:'list_rooms' });
    const errTimer = setTimeout(()=>{
      const e = document.getElementById('lobby-error');
      const ls= document.getElementById('lobby-rooms');
      if (e && ls && !ls.dataset.populated){
        e.textContent = 'No response from server. Lobby features may not be enabled on this server.';
        e.style.display = 'block';
      }
    }, 2000);
    PVP._roomsInterval && clearInterval(PVP._roomsInterval);
    PVP._roomsInterval = setInterval(()=> send({ kind:'list_rooms' }), 2500);
  });
}

function refreshLobbyList(rooms){
  const list = document.getElementById('lobby-rooms');
  const err  = document.getElementById('lobby-error');
  if (!list) return;
  list.textContent = '';
  list.dataset.populated = '1';
  if (err) err.style.display = 'none';

  if (!rooms || rooms.length === 0){
    const empty = el('div', { style:{ opacity:.8, fontSize:'13px', textAlign:'center', padding:'8px' }}, 'No rooms yet. Create one!');
    list.appendChild(empty);
    return;
  }
  for (const r of rooms){
    // server returns {id, name, players}
    const row  = el('div', { style:{ display:'flex', alignItems:'center', justifyContent:'space-between', border:'1px solid #3a4257', background:'#1b2130', borderRadius:'6px', padding:'8px', marginBottom:'6px' }});
    const info = el('div', {}, `${r.id} ‚Äî ${r.name || 'Room'} (${r.players || 1}/2)`);
    const jBtn = el('button', { class:'action-btn', style:{ padding:'6px 10px' }}, el('div', { class:'label', style:{ fontSize:'14px' }}, 'Join'));
    jBtn.onclick = async ()=>{ await connectWS(); send({ kind:'join_room', id: r.id }); };
    row.appendChild(info); row.appendChild(jBtn);
    list.appendChild(row);
  }
}

function showLobbyError(msg){
  const e = document.getElementById('lobby-error');
  if (e){ e.textContent = msg; e.style.display = 'block'; }
}

function setLobbyRoomStatus(id){
  const n = document.getElementById('lobby-room-status');
  if (!n) return;
  if (id){
    n.style.display = 'block';
    n.textContent = `Room ${id} created. Waiting for opponent‚Ä¶  (Share this ID to invite friends)`;
  } else {
    n.style.display = 'none';
    n.textContent = '';
  }
}


/* ---------- Phaser boot ---------- */
function sizeFromBattlefield(){ const r=bfEl.getBoundingClientRect(); const w=Math.max(640,Math.floor(r.width)); const h=Math.max(480,Math.floor(r.height)); return {w,h}; }
function bootPhaser(){ const s=sizeFromBattlefield(); game=new Phaser.Game({ type:Phaser.AUTO, parent:'battlefield', width:s.w, height:s.h, backgroundColor:'#14141b', scene:[GameScene], pixelArt:true }); globalThis.gameRef=game; }
function resizePhaserToBattlefield(){ if(!game||!game.scale) return; const s=sizeFromBattlefield(); if(Number.isFinite(s.w)&&Number.isFinite(s.h)&&s.w>0&&s.h>0){ game.scale.resize(s.w,s.h); } }

window.addEventListener('load', ()=>{
  window.SPRITE_BASE_URL=window.SPRITE_BASE_URL||'https://raw.githubusercontent.com/krezt/tol-assets/main';
  window.ARENA_BG_URL   =window.ARENA_BG_URL   ||'https://raw.githubusercontent.com/krezt/tol-assets/refs/heads/main/bg/arena_bg3.png';
  initActionBarShell(); bootPhaser(); setTimeout(resizePhaserToBattlefield,0);
  if ('ResizeObserver' in window){ const ro=new ResizeObserver(()=>{ resizePhaserToBattlefield(); if(sceneRef&&sceneRef.updateBackgroundLayout) sceneRef.updateBackgroundLayout(); }); ro.observe(bfEl); }
});
window.addEventListener('load', () => {
  if (PVP.phase === 'idle') {
    mountLobbyInField();
setTopBarLobby();
  }
});

window.addEventListener('resize', resizePhaserToBattlefield);

<!-- (continues same <script> tag) -->

/* ---------- PvP bootstrap ---------- */
(function bootstrapPVP(){
  const P=(window.PVP=window.PVP||{});
  P.roundBuf = P.roundBuf || { mine:{}, opp:{}, host:{}, guest:{} };
  P.enabled  = P.enabled ?? false;
  P.ws       = P.ws ?? null;
  P.url      = P.url ?? (window.PVP_WS_URL||'ws://localhost:8080');
  P.meId     = P.meId ?? null;
  P.matchId  = P.matchId ?? null;
  P.roomId   = P.roomId ?? null;
  P.role     = P.role ?? null;                 // 'host' | 'guest'
  P.phase    = P.phase ?? 'idle';              // 'idle' | 'draft' | 'battle'
  P.pool     = P.pool ?? [...ALL_CLASSES];
  P.picksMe  = P.picksMe ?? [];
  P.picksOpp = P.picksOpp ?? [];
  P.pickTurn = P.pickTurn ?? 'me';
  P.pickCount= P.pickCount ?? 0;
  P.sentForRound = null;
  P.playerName = P.playerName || 'You';
  P.opponentName = P.opponentName || 'Opponent';
  P.myName = P.myName || 'You';
})();

function ensureRoundBuf(){
  PVP.roundBuf = PVP.roundBuf || { mine:{}, opp:{}, host:{}, guest:{} };
  PVP.roundBuf.mine  ||= {};
  PVP.roundBuf.opp   ||= {};
  PVP.roundBuf.host  ||= {};
  PVP.roundBuf.guest ||= {};
}

/* ---------- light DOM helper (scoped) ---------- */
function el(tag, attrs = {}, ...kids){
  const n=document.createElement(tag);
  for (const [k,v] of Object.entries(attrs||{})){
    if (k==='class') n.className=v;
    else if (k==='style' && v && typeof v==='object') Object.assign(n.style,v);
    else n.setAttribute(k,v);
  }
  for (const kid of kids){ if (kid==null) continue; n.appendChild(typeof kid==='string'?document.createTextNode(kid):kid); }
  return n;
}

/* ---------- send + connect ---------- */
function send(msg){
  if (PVP.ws && PVP.ws.readyState === WebSocket.OPEN){
    PVP.ws.send(JSON.stringify(msg));
  } else {
    (PVP._outbox ||= []).push(msg);
    console.warn('[PvP] queued (socket not open):', msg.kind);
  }
}

let _wsOpenPromise = null;
function connectWS(){
  if (PVP.ws && (PVP.ws.readyState === WebSocket.OPEN || PVP.ws.readyState === WebSocket.CONNECTING)){
    return _wsOpenPromise || Promise.resolve();
  }
  _wsOpenPromise = new Promise((resolve)=>{
    const roomId = PVP.roomId || 'lobby'; // your code already sets this on create/join
    const RELAY_ORIGIN = 'wss//ros-relay.onrender.com/ws';
    const RELAY_URL = RELAY_ORIGIN + '?room=' + encodeURIComponent(roomId);

    const ws = new WebSocket(RELAY_URL);   // <‚Äî changed line
    PVP.ws = ws;
    // ‚Ä¶keep the rest of your connectWS() exactly as you have it‚Ä¶


    ws.addEventListener('open', ()=>{
      appendLog('[PvP] Connected to matchmaking.');
      ws.send(JSON.stringify({ kind:'hello', build:'ros-pvp-v1' }));

      if (PVP.myName) ws.send(JSON.stringify({ kind:'set_name', name:PVP.myName }));

      // show lobby on idle
      if (PVP.phase === 'idle') {
        mountLobbyInField();
        ws.send(JSON.stringify({ kind:'list_rooms' }));
      }

      // flush queue
      if (Array.isArray(PVP._outbox)){
        for (const m of PVP._outbox) ws.send(JSON.stringify(m));
        PVP._outbox.length = 0;
      }
      if (PVP._wantQueue) ws.send(JSON.stringify({ kind:'queue' }));
      resolve();
    }, { once:true });

    ws.addEventListener('close', ()=>{
      appendLog('[PvP] Disconnected.');
      PVP.enabled=false; PVP.phase='idle';
      mountRightPanel();
      _wsOpenPromise=null;
    });

    ws.addEventListener('error', (e)=>{
      appendLog('[PvP] Connection error.');
      console.error(e);
    });

    ws.addEventListener('message', (ev)=>{
      let msg; try { msg = JSON.parse(ev.data); } catch { return; }
      if (msg && msg.type && !msg.kind) msg.kind = msg.type; // tolerate {type}
      handleNet(msg);
    });
  });
  return _wsOpenPromise;
}


/* ---------- Battle bootstrap after draft (force-rebuild HUD) ---------- */
function startBattleFromDraft(){
  ensureRoundBuf();

  // close any overlays that could cover the scene
  const ov = document.getElementById('draft-overlay'); 
  if (ov) ov.remove();
  if (typeof unmountLobbyInField === 'function') unmountLobbyInField();

  // build units from picks (before restart)
  player = (Array.isArray(PVP.picksMe) ? PVP.picksMe : []).map(job => makeUnit(job, 'player'));
  enemy  = (Array.isArray(PVP.picksOpp) ? PVP.picksOpp : []).map(job => makeUnit(job, 'enemy'));
  ensureUnitSides();  // label units as host/guest before scene restart

  PVP.phase = 'battle';
  PVP._readyForBattle = true; // flag for Scene.create to know we're in battle state

  // restart/boot scene and force a redraw pass shortly after
  if (game && sceneRef) {
    sceneRef.scene.restart();
    setTimeout(() => {
      if (sceneRef && typeof sceneRef.rebuildPanels === 'function') {
        sceneRef.rebuildPanels();
      }
    }, 50);
  } else if (game) {
    game.scene.start('Game');
  } else {
    bootPhaser();
  }

  mountRightPanel && mountRightPanel();
  appendLog('[PvP] Draft complete. Battle begins!');
}

// ============ ROUND SYNC (DROP-IN) ============
(function(){
  // Ensure buffers exist on PVP
  function ensureRoundBuf(){
    if (!PVP.roundBuf) PVP.roundBuf = { mine:{}, opp:{}, host:{}, guest:{} };
    PVP.roundBuf.mine  ||= {};
    PVP.roundBuf.opp   ||= {};
    PVP.roundBuf.host  ||= {};
    PVP.roundBuf.guest ||= {};
  }
  window.ensureRoundBuf = ensureRoundBuf;

  // Convert my local choice to the wire shape
  function choiceToWire(c){
    return {
      actorName:    c.actor?.name || '',
      abilityLabel: c.ability?.label || 'Attack',
      targetName:   (c.ability?.target==='self') ? null :
                    (c.target ? (c.target.name||'') : null)
    };
  }
  window.choiceToWire = choiceToWire;

  // Convert opponent wires back to local enemy-side choices
  function wireToChoiceEnemy(w){
    const actor = enemy.find(u=>u.name===w.actorName) || enemy[0];
    if (!actor) return null;
    const abList  = abilitiesFor(actor);
    const ability = abList.find(a=>a.label===w.abilityLabel) || abList[0];
    let target = null;

    if (w.targetName){
      if (ability.target==='ally')   target = enemy.find(u=>u.name===w.targetName) || null;
      else if (ability.target==='enemy') target = player.find(u=>u.name===w.targetName) || null;
    } else {
      if (ability.target==='self')  target = actor;
      else if (ability.target==='ally')  target = pickCanonical(enemy.filter(u=>u.alive()));
      else if (ability.target==='enemy') target = pickCanonical(player.filter(u=>u.alive()));
    }
    return { actor, ability, target };
  }
  window.wireToChoiceEnemy = wireToChoiceEnemy;

  function buildEnemyChoicesFromRemote(r){
    ensureRoundBuf();
    const theirWire = PVP.roundBuf.opp[r] || [];
    enemyChoices = theirWire.map(wireToChoiceEnemy).filter(Boolean);
    return enemyChoices;
  }
  window.buildEnemyChoicesFromRemote = buildEnemyChoicesFromRemote;

  function shallowEqualJSON(a,b){ try{ return JSON.stringify(a)===JSON.stringify(b); }catch{ return false; } }

  // Called by confirmChoice() after you've locked in everyone
  function sendMyRoundChoices(){
    ensureRoundBuf();
    const r    = roundNumber;
    const wire = (playerChoices || []).map(choiceToWire);

    PVP.roundBuf.mine[r] = wire;
    PVP.sentForRound     = r;
    if (PVP.role === 'host') PVP.roundBuf.host[r]  = wire;
    else                     PVP.roundBuf.guest[r] = wire;

    PVP.waitingForOpp = true;
    if (topLeftEl) topLeftEl.textContent = `Round ${r} ‚Äî Waiting for opponent‚Ä¶`;
    if (typeof clearActionBar === 'function') clearActionBar();

    // Send with both "kind" and "type" for compatibility
    send({
      kind: 'round_choices',
      type: 'round_choices',
      matchId: PVP.matchId,
      roomId:  PVP.roomId,
      round:   r,
      who:     PVP.role,          // 'host' | 'guest'
      choices: wire
    });
  }
  window.sendMyRoundChoices = sendMyRoundChoices;

  // Resolve once both sides for round r are present
  async function tryResolveRoundWithBothSides(r = roundNumber){
    if (PVP.phase !== 'battle') return;
    ensureRoundBuf();
    if (PVP._resolvingRound === r) return;
    PVP._resolvingRound = r;

    // rebuild my queue deterministically
    playerChoices = (PVP.roundBuf.mine[r] || []).map(w => {
      const actor   = player.find(u=>u.name===w.actorName) || pickDeterministic(player);
      const abList  = abilitiesFor(actor);
      const ability = abList.find(a=>a.label===w.abilityLabel) || abList[0];

      let target = null;
      if (w.targetName){
        if (ability.target==='self')  target = actor;
        else if (ability.target==='ally')  target = player.find(u=>u.name===w.targetName) || null;
        else if (ability.target==='enemy') target = enemy.find(u=>u.name===w.targetName) || null;
      }
      if (!target){
        if (ability.target==='self')  target = actor;
        else if (ability.target==='ally')  target = pickCanonical(player.filter(u=>u.alive()));
        else if (ability.target==='enemy') target = pickCanonical(enemy.filter(u=>u.alive()));
      }
      return { actor, ability, target };
    });

    // enemy from remote wires
    buildEnemyChoicesFromRemote(r);

    // seed RNG from both sides‚Äô wires so both clients match
    const hostWire  = PVP.roundBuf.host[r]  || (PVP.role==='host' ? PVP.roundBuf.mine[r] : PVP.roundBuf.opp[r]) || [];
    const guestWire = PVP.roundBuf.guest[r] || (PVP.role==='guest'? PVP.roundBuf.mine[r] : PVP.roundBuf.opp[r]) || [];
    const canon     = canonicalizeChoices(hostWire, guestWire);
    const roundSeed = (fnv1a(String(PVP.matchId||PVP.roomId||'0')) ^ fnv1a(String(r)) ^ fnv1a(canon)) >>> 0;
    seedRNG(roundSeed);
    appendLogHTML(`<span style="color:#ffd37a">‚Äî Round ${r} ‚Äî</span> <span style="opacity:.7">(seed ${roundSeed})</span>`);
    appendLogHTML(`<span style="opacity:.7">state# pre=${roundStateChecksum()}</span>`);
    const outcome = await resolveSimultaneous();
    appendLogHTML(`<span style="opacity:.7">state# post=${roundStateChecksum()}</span>`);
    PVP.waitingForOpp = false;

    if (outcome !== 'continue'){
      if (topLeftEl) topLeftEl.textContent = (outcome==='win')?'Victory!':'Defeat.';
      if (typeof clearActionBar === 'function') clearActionBar();
      if (typeof showEndOverlay === 'function') showEndOverlay(outcome==='win'?'win':'lose');

      send({
        kind: 'outcome',
        type: 'outcome',
        matchId: PVP.matchId,
        roomId:  PVP.roomId,
        round:   r,
        outcome
      });
      PVP._resolvingRound = null;
      return;
    }

    // advance to next round
    roundNumber++;
    delete PVP.roundBuf.mine[r];
    delete PVP.roundBuf.opp[r];
    PVP.sentForRound = null;

    resetRoundState();
    updateTopBarForCurrentSelection();
    renderActionBarForCurrent();
    if (typeof mountRightPanel === 'function') mountRightPanel();

    PVP._resolvingRound = null;
  }
  window.tryResolveRoundWithBothSides = tryResolveRoundWithBothSides;
})();

// ===== END OVERLAY (DROP-IN) =====
window.showEndOverlay = function(outcome){ // 'win' | 'lose' | 'draw'
  let ov = document.getElementById('result-overlay'); if (ov) ov.remove();
  ov = document.createElement('div'); ov.id='result-overlay';
  Object.assign(ov.style,{
    position:'fixed', inset:'0', background:'rgba(10,12,16,0.92)',
    zIndex:9999, display:'flex', alignItems:'center', justifyContent:'center', padding:'16px'
  });

  const card = document.createElement('div');
  Object.assign(card.style,{
    width:'min(720px,92vw)', background:'#1b2130', border:'2px solid #3a4257', borderRadius:'8px',
    boxShadow:'0 10px 40px rgba(0,0,0,.5)', padding:'24px', display:'flex',
    flexDirection:'column', gap:'18px', alignItems:'center'
  });

  const title = document.createElement('div');
  title.style.cssText = 'font-size:36px;font-weight:900;';
  title.textContent = (outcome==='win') ? 'üèÜ Victory!' : (outcome==='lose' ? 'üíÄ Defeat' : '‚è∏ Draw');
  card.appendChild(title);

  const row = document.createElement('div');
  row.style.cssText = 'display:flex;gap:10px;flex-wrap:wrap;justify-content:center;';

  function mk(label, onClick){
    const b = document.createElement('button');
    b.className = 'action-btn'; b.style.padding = '12px 16px';
    b.innerHTML = `<div class="label" style="font-size:18px">${label}</div>`;
    b.onclick = onClick; return b;
  }

  const toLobby = () => {
    ov.remove();
    PVP.matchId=null; PVP.role=null; PVP.phase='idle';
    player=[]; enemy=[];
    if (game && sceneRef) sceneRef.scene.restart();
enterLobbyUI(); 
    if (typeof mountLobbyInField==='function') mountLobbyInField();
    setTopBarLobby();

    // (Optional) Clear any stray unit panels if the scene hasn't rebuilt yet
    if (sceneRef){
      sceneRef.playerCol && sceneRef.playerCol.removeAll(true);
      sceneRef.enemyCol  && sceneRef.enemyCol.removeAll(true);
    }
    connectWS().then(()=> send({kind:'list_rooms'}));
  };

  const playAgain = () => {
    ov.remove();
    PVP.matchId=null; PVP.role=null; PVP.phase='idle';
    player=[]; enemy=[];
    if (game && sceneRef) sceneRef.scene.restart();
enterLobbyUI(); 
    if (typeof mountLobbyInField==='function') mountLobbyInField();
    setTopBarLobby();

    // (Optional) Clear any stray unit panels if the scene hasn't rebuilt yet
    if (sceneRef){
      sceneRef.playerCol && sceneRef.playerCol.removeAll(true);
      sceneRef.enemyCol  && sceneRef.enemyCol.removeAll(true);
    }
    connectWS().then(()=> send({ kind:'queue' }));
  };

  row.appendChild(mk('Return to Lobby', toLobby));
  row.appendChild(mk('Play Again',      playAgain));
  card.appendChild(row);
  ov.appendChild(card);
  document.body.appendChild(ov);
};

/* ---------- Net handler ---------- */
function handleNet(msg){
  switch(msg.kind){

    case 'hello_ack': {
      PVP.meId = msg.id;
      break;
    }

    case 'queued': {
      appendLog('[PvP] Searching for opponent‚Ä¶');
      PVP.enabled = true; PVP.phase = 'idle';
      break;
    }

    case 'opponent_disconnected': {
      appendLog('[PvP] Opponent disconnected.');
      PVP._ended = false;
      PVP.matchId = PVP.roomId = null;
      PVP.role = null; PVP.phase = 'idle';
      player = []; enemy = [];
      if (game && sceneRef) sceneRef.scene.restart();
      mountLobbyInField();
      break;
    }

    // Lobby replies
    case 'rooms': {
      refreshLobbyList(Array.isArray(msg.rooms) ? msg.rooms : []);
      break;
    }
    case 'room_created': {
      setLobbyRoomStatus(msg.id);
      send({ kind:'list_rooms' }); // refresh
      break;
    }
    case 'room_joined': {
      appendLog('[PvP] Joined room. Waiting for opponent‚Ä¶');
      break;
    }
    case 'error': {
      appendLog('[PvP] ' + (msg.msg || 'Error.'));
      showLobbyError(msg.msg || 'Server error.');
      break;
    }
case 'round_choices': {
  ensureRoundBuf();
  const r  = (typeof msg.round==='number') ? msg.round : roundNumber;
  const ch = Array.isArray(msg.choices) ? msg.choices : [];

  let bucket;
  if (msg.who==='host' || msg.who==='guest'){
    bucket = (msg.who === PVP.role) ? 'mine' : 'opp';
    PVP.roundBuf[msg.who][r] = ch;    // keep per-side copy for seeding
  } else {
    // fallback: decide by actor names present
    const names   = ch.map(c=>c.actorName);
    const myNames = (player||[]).map(u=>u.name);
    const allIn   = names.length && names.every(n=>myNames.includes(n));
    bucket = allIn ? 'mine' : 'opp';
  }
  PVP.roundBuf[bucket][r] = ch;

  if (PVP.phase==='battle' && r===roundNumber &&
      Array.isArray(PVP.roundBuf.mine[r]) && Array.isArray(PVP.roundBuf.opp[r])){
    tryResolveRoundWithBothSides(r);
  }
  break;
}

    // Names (various shapes)
    case 'opponent_name':
    case 'peer_name':
    case 'name_update':
    case 'name': {
      const theirRole = msg.who || msg.role || msg.from || null;
      const name      = msg.name || msg.opponentName || msg.playerName || '';
      const isFromMe  = (theirRole && theirRole === PVP.role);
      if (name && !isFromMe){
        PVP.opponentName = name;
        if (sceneRef && sceneRef.updateHeaderNames) sceneRef.updateHeaderNames();
        const oppTitle = document.getElementById('oppTitle');
        if (oppTitle) oppTitle.textContent = PVP.opponentName || 'Opponent';
      }
      break;
    }

    // Match start (rooms flow)
    case 'match': {
  // Lobby server variant
  PVP.roomId = msg.roomId || PVP.roomId;
  // map A/B to host/guest for your existing code paths
  PVP.role   = (msg.you === 'A') ? 'host' : 'guest';
  PVP.matchId = PVP.roomId; // keep both populated for compatibility

  // --- draft init ---
  PVP.phase = 'draft';
  PVP.pool = [...ALL_CLASSES];
  PVP.picksMe = [];
  PVP.picksOpp = [];
  PVP.pickCount = 0;

  // --- IMPORTANT: who picks first ---
  PVP.starter = 'host';                // A starts (matches server draftSeq)
  const sideTurn = PVP.starter;
  PVP.pickTurn = (sideTurn === PVP.role) ? 'me' : 'opp';

  // UI
  unmountLobbyInField && unmountLobbyInField();
  mountDraftUI();
  updateDraftUI();
  appendLog('[PvP] Match ready. Draft begins.');
  break;
}


    // Draft pick
    case 'draft_pick': {
      const by = msg.by, job = msg.job;
      PVP.pool = PVP.pool.filter(j => j !== job);
      if ((by === PVP.role) || (by === 'host' && PVP.role === 'host') || (by === 'guest' && PVP.role === 'guest')){
        PVP.picksMe.push(job);
      } else {
        PVP.picksOpp.push(job);
      }
      PVP.pickCount++;

      // Alternate turns (A,B,A,B,A,B) with starter host
      const starter = 'host';
      const sideTurn = (PVP.pickCount % 2 === 0) ? starter : (starter === 'host' ? 'guest' : 'host');
      PVP.pickTurn = (sideTurn === PVP.role) ? 'me' : 'opp';

      updateDraftUI();
      if (PVP.picksMe.length === 3 && PVP.picksOpp.length === 3){
        startBattleFromDraft();
      }
      break;
    }

    // Round wires
    case 'round_choices': {
      ensureRoundBuf();
      const r  = (typeof msg.round === 'number') ? msg.round : roundNumber;
      const ch = Array.isArray(msg.choices) ? msg.choices : [];
      let bucket;
      if (msg.who === 'host' || msg.who === 'guest') {
        bucket = (msg.who === PVP.role) ? 'mine' : 'opp';
      } else {
        const names = ch.map(c => c.actorName);
        const myNames = (player || []).map(u => u.name);
        const allIn = (arr,sup)=> arr.length && arr.every(n => sup.includes(n));
        bucket = allIn(names, myNames) ? 'mine' : 'opp';
      }

      const existing = PVP.roundBuf[bucket][r];
      if (JSON.stringify(existing) !== JSON.stringify(ch)) PVP.roundBuf[bucket][r] = ch;
      if (msg.who === 'host' || msg.who === 'guest') {
        const sideExisting = PVP.roundBuf[msg.who][r];
        if (JSON.stringify(sideExisting) !== JSON.stringify(ch)) PVP.roundBuf[msg.who][r] = ch;
      }

      if (PVP.phase === 'battle' && r === roundNumber &&
          Array.isArray(PVP.roundBuf.mine[r]) && Array.isArray(PVP.roundBuf.opp[r])){
        tryResolveRoundWithBothSides(r);
      }
      break;
    }

    // Final outcome (flip perspective if needed)
    case 'outcome': {
      if (PVP._ended) break;
      let out = msg.outcome;
      if (msg.from && msg.from !== PVP.role){
        out = (out === 'win') ? 'lose' : (out === 'lose' ? 'win' : out);
      }
      PVP._ended = true;
      if (topLeftEl) topLeftEl.textContent = (out === 'win') ? 'Victory!' : 'Defeat.';
      clearActionBar();
      showEndOverlay(out === 'win' ? 'win' : 'lose');
      break;
    }

    default: break;
  }
}

/* ---------- Right panel (names + find match) ---------- */
function showRightWaitHint(){
  const box = document.getElementById('action-bar-right');
  if (!box) return;
  box.textContent = '';
  const hint = document.createElement('div');
  hint.style.cssText = 'font-size:12px;opacity:.85;text-align:center;padding:8px;';
  hint.textContent = 'Waiting for opponent‚Ä¶';
  box.appendChild(hint);
}

function mountRightPanel(){
  // Intentionally blank: all controls live in the battlefield lobby overlay now.
  const panel = document.getElementById('action-bar-right');
  if (panel) panel.textContent = '';
}


/* ---------- Draft UI ---------- */
function getOrCreateDraftOverlay(){
  let ov=document.getElementById('draft-overlay'); if (ov) return ov;
  ov=document.createElement('div'); ov.id='draft-overlay';
  Object.assign(ov.style,{position:'fixed',inset:'0',background:'rgba(10,12,16,0.92)',zIndex:'9999',display:'flex',alignItems:'center',justifyContent:'center',padding:'16px'});
  const card=document.createElement('div'); card.id='draft-card';
  Object.assign(card.style,{width:'min(1000px,92vw)',height:'min(720px,88vh)',background:'#1b2130',border:'2px solid #3a4257',borderRadius:'8px',display:'flex',flexDirection:'column',overflow:'hidden',boxShadow:'0 10px 40px rgba(0,0,0,.5)'});

  const header=document.createElement('div'); header.id='draft-header';
  Object.assign(header.style,{padding:'12px 16px',borderBottom:'1px solid #3a4257',display:'flex',alignItems:'center',justifyContent:'space-between',gap:'8px'});
  header.innerHTML=`<div style="font-weight:800;font-size:20px;">Draft: Pick 3 Heroes</div><div id="draft-sub" style="font-size:13px;opacity:.9;">You are <b>${PVP.role}</b>. Turn: <b id="turnChip"></b></div>`;

  const picksRow=document.createElement('div'); picksRow.id='draft-picks-row';
  Object.assign(picksRow.style,{padding:'12px 16px',display:'grid',gridTemplateColumns:'1fr 1fr',gap:'16px',borderBottom:'1px solid #3a4257'});
  picksRow.innerHTML=`<div><div style="font-weight:700;margin-bottom:6px;">Your Picks</div><div id="myPicks" style="min-height:24px;opacity:.95"></div></div>
                      <div><div id="oppTitle" style="font-weight:700;margin-bottom:6px;">${PVP.opponentName||'Opponent'}</div><div id="oppPicks" style="min-height:24px;opacity:.95"></div></div>`;

  const poolWrap=document.createElement('div'); poolWrap.id='draft-pool-wrap';
  Object.assign(poolWrap.style,{padding:'12px 16px',display:'flex',flexDirection:'column',gap:'8px',minHeight:0,flex:'1 1 auto'});
  const poolHeader=document.createElement('div'); poolHeader.innerHTML=`
    <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
      <div style="font-weight:700;">Available</div>
      <input id="draft-filter" placeholder="Filter classes‚Ä¶" style="background:#22314b;color:#fff;border:1px solid #4a5a7a;border-radius:4px;padding:6px 8px;min-width:180px;">
    </div>`;
  const pool=document.createElement('div'); pool.id='pool';
  Object.assign(pool.style,{display:'grid',gridTemplateColumns:'repeat(auto-fill, minmax(160px, 1fr))',gap:'8px',overflow:'auto',minHeight:0,flex:'1 1 auto',paddingBottom:'4px'});
  poolWrap.appendChild(poolHeader); poolWrap.appendChild(pool);

  const footer=document.createElement('div');
  Object.assign(footer.style,{padding:'10px 16px',borderTop:'1px solid #3a4257',display:'flex',alignItems:'center',justifyContent:'space-between',fontSize:'12px',opacity:'.85'});
  footer.innerHTML=`<div>Alternating draft (A‚ÄìB‚ÄìA‚ÄìB‚ÄìA‚ÄìB). Battle starts when each player has 3 picks.</div><button id="draft-cancel" class="action-btn" style="padding:6px 10px;">Cancel</button>`;

  card.appendChild(header); card.appendChild(picksRow); card.appendChild(poolWrap); card.appendChild(footer); ov.appendChild(card); document.body.appendChild(ov);
  document.getElementById('draft-cancel').onclick=()=>{ const ovNow=document.getElementById('draft-overlay'); if (ovNow) ovNow.remove(); };
  const filter=document.getElementById('draft-filter'); filter.addEventListener('input', ()=>updateDraftUI());
  return ov;
}

function mountDraftUI(){
  getOrCreateDraftOverlay();
  const box=document.getElementById('action-bar-right');
  if (box){ box.textContent=''; const hint=document.createElement('div'); hint.style.cssText='font-size:12px;opacity:.85;text-align:center;padding:8px;'; hint.textContent='Draft in progress‚Ä¶'; box.appendChild(hint); }
  updateDraftUI();
}

function updateDraftUI(){
  const turnChip=document.getElementById('turnChip');
  if (turnChip){ const mine=(PVP.pickTurn==='me'); turnChip.textContent=mine?'Your pick':'Opponent'; turnChip.style.color=mine?'#a7ffb5':'#ffd37a'; }
  const myP=document.getElementById('myPicks'); const opP=document.getElementById('oppPicks');
  if (myP) myP.textContent=(PVP.picksMe.join(', ')||'‚Äî'); if (opP) opP.textContent=(PVP.picksOpp.join(', ')||'‚Äî');
  const oppTitle = document.getElementById('oppTitle'); if (oppTitle) oppTitle.textContent = PVP.opponentName || 'Opponent';

  const pool=document.getElementById('pool'); if(!pool) return;
  const filter=document.getElementById('draft-filter'); const q=(filter?.value||'').trim().toLowerCase();
  pool.textContent=''; const remaining=PVP.pool.filter(j=>!q||j.toLowerCase().includes(q));
  for (const job of remaining){
    const b=document.createElement('button'); b.className='action-btn';
    Object.assign(b.style,{padding:'8px',textAlign:'left',whiteSpace:'normal',lineHeight:'1.2',display:'flex',flexDirection:'column',gap:'4px'});
    const title=document.createElement('div'); title.className='label'; title.textContent=job;
    const desc=document.createElement('div'); desc.className='desc'; desc.textContent=JOBS[job]?`STR ${JOBS[job].STR} ‚Ä¢ INT ${JOBS[job].INT} ‚Ä¢ QKN ${JOBS[job].QKN} ‚Ä¢ TGH ${JOBS[job].TGH}`:'';
    b.appendChild(title); b.appendChild(desc);
    b.disabled=(PVP.pickTurn!=='me');
    b.onclick = () => {
      if (PVP.pickTurn !== 'me') return;
      b.disabled = true;
      send({ kind:'draft_pick', job, by:PVP.role });
    };
    pool.appendChild(b);
  }
  if (!pool.children.length){
    const empty=document.createElement('div'); empty.style.cssText='opacity:.8;font-size:13px;padding:12px;'; empty.textContent=q?'No classes match your filter.':'No classes remaining.'; pool.appendChild(empty);
  }
}


/* ===== Lobby overlay in battlefield (DOM, not Phaser) ===== */
function unmountLobbyInField(){
  const ov = document.getElementById('lobby-overlay');
  if (ov) ov.remove();
}

function mountLobbyInField(){
  unmountLobbyInField();
  const root = document.getElementById('battlefield');
  if (!root) return;
  root.style.position = 'relative';

  const ov = document.createElement('div');
  ov.id = 'lobby-overlay';
  Object.assign(ov.style, {
    position:'absolute', inset:'8px',
    background:'rgba(10,12,16,0.92)', border:'2px solid #3a4257', borderRadius:'8px',
    color:'#e8e8f0', zIndex: 5, display:'flex', flexDirection:'column', gap:'10px', padding:'12px'
  });

  // Header + name
  const header = el('div', { style:{ display:'flex', alignItems:'center', justifyContent:'space-between', gap:'8px' }});
  header.appendChild(el('div', { style:{ fontWeight:'800', fontSize:'20px' }}, 'PvP Lobby'));
  const nameWrap = el('div', { style:{ display:'flex', gap:'6px', alignItems:'center' }});
  nameWrap.appendChild(el('label', { style:{ fontSize:'12px', opacity:.9 }}, 'Your name:'));
  const nameInput = el('input', { id:'lobby-name', placeholder:'Type your name', value:(PVP.myName||PVP.playerName||'') });
  Object.assign(nameInput.style, { background:'#22314b', color:'#fff', border:'1px solid #4a5a7a', borderRadius:'4px', padding:'6px 8px', minWidth:'160px' });
  const saveBtn = el('button', { class:'action-btn', style:{ padding:'6px 10px' }}, el('div', { class:'label', style:{ fontSize:'14px' }}, 'Save'));
  header.appendChild(nameWrap);
  nameWrap.appendChild(nameInput); nameWrap.appendChild(saveBtn);
  ov.appendChild(header);

  // Tip + error
  const tip  = el('div', { id:'lobby-tip',  style:{ fontSize:'12px', opacity:.85, textAlign:'center' }}, 'Tip: share the room ID so friends can join.');
  const err  = el('div', { id:'lobby-error',style:{ fontSize:'12px', color:'#ffb3b3', textAlign:'center', display:'none' }}, '');
  ov.appendChild(tip); ov.appendChild(err);

  // Controls: Create room, Quick Match, Join by ID
  const controls = el('div', { style:{ display:'flex', gap:'8px', flexWrap:'wrap', justifyContent:'center' }});
  const mkBtn = (label, onClick) => {
    const b = el('button', { class:'action-btn', style:{ padding:'8px 12px' }}, el('div', { class:'label', style:{ fontSize:'16px' }}, label));
    b.onclick = onClick; return b;
  };
  const createBtn = mkBtn('Create Room', async ()=>{ await connectWS(); send({ kind:'create_room' }); });
  const quickBtn  = mkBtn('Quick Match', async ()=>{ await connectWS(); send({ kind:'queue' }); });
  controls.appendChild(createBtn); controls.appendChild(quickBtn);

  // Join by ID
  const joinWrap = el('div', { style:{ display:'flex', gap:'6px', alignItems:'center', justifyContent:'center' }});
  const joinInp  = el('input', { id:'lobby-join-id', placeholder:'Enter room ID' });
  Object.assign(joinInp.style, { background:'#22314b', color:'#fff', border:'1px solid #4a5a7a', borderRadius:'4px', padding:'6px 8px', minWidth:'140px' });
  const joinBtn  = mkBtn('Join', async ()=>{ const id=(joinInp.value||'').trim(); if(!id) return; await connectWS(); send({ kind:'join_room', id }); });
  joinWrap.appendChild(joinInp); joinWrap.appendChild(joinBtn);

  ov.appendChild(controls);
  ov.appendChild(joinWrap);

  // Status after create
  const roomStatus = el('div', { id:'lobby-room-status', style:{ display:'none', textAlign:'center', fontSize:'13px' }});
  ov.appendChild(roomStatus);

  // List
  const list = el('div', { id:'lobby-rooms', style:{ marginTop:'6px', overflow:'auto', flex:'1 1 auto', borderTop:'1px solid #3a4257', paddingTop:'8px' }});
  ov.appendChild(list);

  root.appendChild(ov);

  // Save name handlers
  const saveName = () => {
    const v = (nameInput.value || '').trim().slice(0,16);
    if (!v) return;
    PVP.myName = v; PVP.playerName = v;
    connectWS().then(()=> send({ kind:'set_name', name:v }));
    if (sceneRef && sceneRef.updateHeaderNames) sceneRef.updateHeaderNames();
  };
  saveBtn.onclick = saveName;
  nameInput.addEventListener('keydown', e => { if (e.key==='Enter') { e.preventDefault(); saveName(); }});
  nameInput.addEventListener('blur', saveName);

  // Ask for rooms + periodic refresh
  connectWS().then(()=>{
    send({ kind:'list_rooms' });
    const errTimer = setTimeout(()=>{
      const e = document.getElementById('lobby-error');
      const ls= document.getElementById('lobby-rooms');
      if (e && ls && !ls.dataset.populated){
        e.textContent = 'No response from server. Lobby features may not be enabled on this server.';
        e.style.display = 'block';
      }
    }, 2000);
    PVP._roomsInterval && clearInterval(PVP._roomsInterval);
    PVP._roomsInterval = setInterval(()=> send({ kind:'list_rooms' }), 2500);
  });
}

function refreshLobbyList(rooms){
  const list = document.getElementById('lobby-rooms');
  const err  = document.getElementById('lobby-error');
  if (!list) return;
  list.textContent = '';
  list.dataset.populated = '1';
  if (err) err.style.display = 'none';

  if (!rooms || rooms.length === 0){
    const empty = el('div', { style:{ opacity:.8, fontSize:'13px', textAlign:'center', padding:'8px' }}, 'No rooms yet. Create one!');
    list.appendChild(empty);
    return;
  }
  for (const r of rooms){
    // server returns {id, name, players}
    const row  = el('div', { style:{ display:'flex', alignItems:'center', justifyContent:'space-between', border:'1px solid #3a4257', background:'#1b2130', borderRadius:'6px', padding:'8px', marginBottom:'6px' }});
    const info = el('div', {}, `${r.id} ‚Äî ${r.name || 'Room'} (${r.players || 1}/2)`);
    const jBtn = el('button', { class:'action-btn', style:{ padding:'6px 10px' }}, el('div', { class:'label', style:{ fontSize:'14px' }}, 'Join'));
    jBtn.onclick = async ()=>{ await connectWS(); send({ kind:'join_room', id: r.id }); };
    row.appendChild(info); row.appendChild(jBtn);
    list.appendChild(row);
  }
}

function showLobbyError(msg){
  const e = document.getElementById('lobby-error');
  if (e){ e.textContent = msg; e.style.display = 'block'; }
}

function setLobbyRoomStatus(id){
  const n = document.getElementById('lobby-room-status');
  if (!n) return;
  if (id){
    n.style.display = 'block';
    n.textContent = `Room ${id} created. Waiting for opponent‚Ä¶  (Share this ID to invite friends)`;
  } else {
    n.style.display = 'none';
    n.textContent = '';
  }
}


/* ---------- Boot right panel on load ---------- */
window.addEventListener('load', ()=>{ if (PVP.phase!=='draft') mountRightPanel(); });

</script>
</body>
</html>



